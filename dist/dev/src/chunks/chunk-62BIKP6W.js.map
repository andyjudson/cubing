{
  "version": 3,
  "sources": ["../../../../node_modules/cubing/src/cubing/kpuzzle/combine.ts", "../../../../node_modules/cubing/src/cubing/kpuzzle/construct.ts", "../../../../node_modules/cubing/src/cubing/kpuzzle/KPattern.ts", "../../../../node_modules/cubing/src/cubing/kpuzzle/KTransformation.ts", "../../../../node_modules/cubing/src/cubing/kpuzzle/calculate.ts", "../../../../node_modules/cubing/src/cubing/kpuzzle/KPuzzle.ts", "../../../../node_modules/cubing/src/cubing/puzzles/stickerings/mask.ts", "../../../../node_modules/cubing/src/cubing/puzzles/stickerings/puzzle-stickerings.ts", "../../../../node_modules/cubing/src/cubing/puzzles/stickerings/cube-like-stickerings.ts", "../../../../node_modules/cubing/src/cubing/puzzles/async/lazy-cached.ts", "../../../../node_modules/cubing/src/cubing/vendor/mit/p-lazy/p-lazy.ts", "../../../../node_modules/cubing/src/cubing/puzzles/async/async-pg3d.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/3x3x3.kpuzzle.json.ts", "../../../../node_modules/cubing/src/cubing/puzzles/PuzzleLoader.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/2x2x2/puzzle-orientation.ts", "../../../../node_modules/cubing/src/cubing/puzzles/customPGPuzzleLoader.ts", "../../../../node_modules/cubing/src/cubing/puzzles/cubing-private/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/dynamic/3x3x3/puzzle-orientation.ts", "../../../../node_modules/cubing/src/cubing/puzzles/events.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/2x2x2/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/puzzle-specific-simplifications.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/3x3x3/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/clock/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/stickerings/fto-stickerings.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/fto/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/stickerings/megaminx-stickerings.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/megaminx/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/pyraminx/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/square1/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/kilominx/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/redi-cube/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/4x4x4/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/melindas2x2x2x2/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/implementations/loopover/index.ts", "../../../../node_modules/cubing/src/cubing/puzzles/index.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    const orbit1 = transformationData1[orbitDefinition.orbitName];\n    const orbit2 = transformationData2[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitDefinition.orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: orbit1.orientationDelta,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientationDelta[orbit2.permutation[idx]] +\n              orbit2.orientationDelta[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToKPatternData(\n  definition: KPuzzleDefinition,\n  patternData: KPatternData,\n  transformationData: KTransformationData,\n): KPatternData {\n  const newPatternData = {} as KPatternData;\n  for (const orbitDefinition of definition.orbits) {\n    const patternOrbit = patternData[orbitDefinition.orbitName];\n    const transformationOrbit = transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        transformationOrbit,\n      )\n    ) {\n      // common case for big cubes\n      newPatternData[orbitDefinition.orbitName] = patternOrbit;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] =\n            patternOrbit.pieces[transformationOrbit.permutation[idx]];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: patternOrbit.orientation, // copy all 0\n        };\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      } else {\n        const newOrientation = new Array(orbitDefinition.numPieces);\n        const newOrientationMod: number[] | undefined =\n          patternOrbit.orientationMod\n            ? new Array(orbitDefinition.numPieces)\n            : undefined;\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          const transformationIdx = transformationOrbit.permutation[idx];\n          let mod = orbitDefinition.numOrientations;\n          if (patternOrbit.orientationMod) {\n            const orientationMod =\n              patternOrbit.orientationMod[transformationIdx];\n            newOrientationMod![idx] = orientationMod;\n            mod = orientationMod || orbitDefinition.numOrientations;\n          }\n          newOrientation[idx] =\n            (patternOrbit.orientation[transformationIdx] +\n              transformationOrbit.orientationDelta[idx]) %\n            mod; // We don't have to use `modIntoRange` (assuming input is well-formed), because we're adding.\n          newPieces[idx] = patternOrbit.pieces[transformationIdx];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: newOrientation,\n        };\n        if (newOrientationMod) {\n          newOrbitData.orientationMod = newOrientationMod;\n        }\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      }\n    }\n  }\n  return newPatternData;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientationDelta: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    transformation[orbitDefinition.orbitName] =\n      constructIdentityOrbitTransformation(orbitDefinition.numPieces);\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  function getTransformationData(\n    key: {\n      toString: () => string;\n    },\n    multiplyAmount: number,\n  ): KTransformationData | undefined {\n    const s = key.toString();\n    const movesDef = kpuzzle.definition.moves[s];\n    if (movesDef) {\n      return repeatTransformationUncached(kpuzzle, movesDef, multiplyAmount);\n    }\n    const derivedDef = kpuzzle.definition.derivedMoves?.[s];\n    if (derivedDef) {\n      return repeatTransformationUncached(\n        kpuzzle,\n        kpuzzle.algToTransformation(derivedDef).transformationData,\n        multiplyAmount,\n      );\n    }\n    return undefined;\n  }\n\n  // TODO: Use Euclid's algorithm to pre-calculate the GCD of moves for each\n  // quantum, along with its transformation. This will make lookup `O(1)` for multiples of e.g. `y2`.\n\n  const data =\n    getTransformationData(move.quantum, move.amount) ??\n    // Handle e.g. `y2` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move, 1) ??\n    // Handle e.g. `y2'` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move.invert, -1);\n\n  if (data) {\n    return data;\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToKPatternData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KPatternData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\nimport { isPatternDataIdentical } from \"./calculate\";\n\nexport class KPattern {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly patternData: KPatternData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      patternData: this.patternData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KPattern {\n    const newPatternData = applyTransformationDataToKPatternData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.defaultPattern,\n      transformation.transformationData,\n    );\n    return new KPattern(transformation.kpuzzle, newPatternData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KPattern {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KPattern {\n    if (transformation.isIdentityTransformation()) {\n      return new KPattern(this.kpuzzle, this.patternData);\n    }\n    const newPatternData = applyTransformationDataToKPatternData(\n      this.kpuzzle.definition,\n      this.patternData,\n      transformation.transformationData,\n    );\n    return new KPattern(this.kpuzzle, newPatternData);\n  }\n\n  applyMove(move: Move | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  isIdentical(other: KPattern): boolean {\n    return isPatternDataIdentical(\n      this.kpuzzle,\n      this.patternData,\n      other.patternData,\n    );\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertDefaultPatternToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, patternOrbitData] of Object.entries(\n      this.patternData,\n    )) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: patternOrbitData.pieces,\n        orientationDelta: patternOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsPatternSolved) {\n      throw new Error(\n        \"`KPattern.experimentalIsPatternSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsPatternSolved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKPattern(): KPattern {\n    return KPattern.fromTransformation(this);\n  }\n\n  // TODO: support calculating this for a given start state. (For `R U R' U` on 3x3x3, should this default to 5 or 10?)\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  if (!orbitTransformationData.permutation) {\n    console.log(orbitTransformationData);\n  }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientationDelta: orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePiecePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      orbitTransformationData1.orientationDelta[idx] !==\n        orbitTransformationData2.orientationDelta[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePiecePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitDefinition.orbitName],\n        transformationData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isOrbitPatternDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitPatternData1: KPatternOrbitData,\n  orbitPatternData2: KPatternOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePieceIndices?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      (orbitPatternData1.orientation[idx] !==\n        orbitPatternData2.orientation[idx] ||\n        (orbitPatternData1.orientationMod?.[idx] ?? 0) !==\n          (orbitPatternData2.orientationMod?.[idx] ?? 0))\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePieceIndices &&\n      orbitPatternData1.pieces[idx] !== orbitPatternData2.pieces[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isPatternDataIdentical(\n  kpuzzle: KPuzzle,\n  patternData1: KPatternData,\n  patternData2: KPatternData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitPatternDataIdentical(\n        orbitDefinition,\n        patternData1[orbitDefinition.orbitName],\n        patternData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    const orbitTransformationData =\n      transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] =\n        orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: orbitTransformationData.orientationDelta,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientationDelta[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertDefaultPatternToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const orbitDefinition of definition.orbits) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.defaultPattern[\n      orbitDefinition.orbitName\n    ].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitDefinition of definition.orbits) {\n    const transformationOrbit =\n      transformation.transformationData[orbitDefinition.orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientationDelta[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KPuzzleOrbitDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  #indexedOrbits: Record<string, KPuzzleOrbitDefinition> | undefined;\n  // Note: this function is needed much more rarely than you might think. Most\n  // operations related to orbits require iterating through all of them, for\n  // which the following is better:\n  //\n  //    for (const orbitDefinition of kpuzzle.definition.orbits) { // \u2026\n  //    }\n  lookupOrbitDefinition(orbitName: string): KPuzzleOrbitDefinition {\n    this.#indexedOrbits ||= (() => {\n      const indexedOrbits: Record<string, KPuzzleOrbitDefinition> = {};\n      for (const orbitDefinition of this.definition.orbits) {\n        indexedOrbits[orbitDefinition.orbitName] = orbitDefinition;\n      }\n      return indexedOrbits;\n    })();\n    return this.#indexedOrbits[orbitName];\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  defaultPattern(): KPattern {\n    return new KPattern(this, this.definition.defaultPattern);\n  }\n\n  #cachedCanConvertDefaultPatternToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete default pattern data\n  canConvertDefaultPatternToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertDefaultPatternToUniqueTransformation ??=\n      ((): boolean => {\n        for (const orbitDefinition of this.definition.orbits) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.defaultPattern[\n            orbitDefinition.orbitName\n          ].pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n", "// TODO: figure out where to house this permanently.\n\nimport type { Move } from \"../../alg\";\nimport type { KPuzzle } from \"../../kpuzzle\";\n\nexport type FaceletMeshStickeringMask =\n  | \"regular\"\n  | \"dim\"\n  | \"oriented\"\n  | \"experimentalOriented2\" // TODO\n  | \"ignored\"\n  | \"invisible\";\n\nexport type FaceletStickeringMask = {\n  mask: FaceletMeshStickeringMask;\n  hintMask?: FaceletMeshStickeringMask;\n};\n\nexport type PieceStickeringMask = {\n  // TODO: foundation?\n  facelets: (FaceletMeshStickeringMask | FaceletStickeringMask | null)[];\n};\n\nexport type OrbitStickeringMask = {\n  pieces: (PieceStickeringMask | null)[];\n};\n\nexport type StickeringMask = {\n  specialBehaviour?: \"picture\"; // TODO: remove this\n  name?: string; // TODO\n  orbits: Record<string, OrbitStickeringMask>;\n};\n\nexport function getFaceletStickeringMask(\n  stickeringMask: StickeringMask,\n  orbitName: string,\n  pieceIdx: number,\n  faceletIdx: number,\n  hint: boolean,\n): FaceletMeshStickeringMask {\n  const orbitStickeringMask = stickeringMask.orbits[orbitName];\n  const pieceStickeringMask: PieceStickeringMask | null =\n    orbitStickeringMask.pieces[pieceIdx];\n  if (pieceStickeringMask === null) {\n    return regular;\n  }\n  const faceletStickeringMask:\n    | FaceletMeshStickeringMask\n    | FaceletStickeringMask\n    | null = pieceStickeringMask.facelets?.[faceletIdx];\n  if (faceletStickeringMask === null) {\n    return regular;\n  }\n  if (typeof faceletStickeringMask === \"string\") {\n    return faceletStickeringMask;\n  }\n  if (hint) {\n    return faceletStickeringMask.hintMask ?? faceletStickeringMask.mask;\n  }\n  console.log(faceletStickeringMask);\n  return faceletStickeringMask.mask;\n}\n\n// TODO: Revert this to a normal enum, or write a standard to codify the names?\nexport enum PieceStickering {\n  Regular = \"Regular\",\n  Dim = \"Dim\",\n  Ignored = \"Ignored\",\n  OrientationStickers = \"OrientationStickers\",\n  Invisible = \"Invisible\",\n  Ignoriented = \"Ignoriented\",\n  IgnoreNonPrimary = \"IgnoreNonPrimary\",\n  PermuteNonPrimary = \"PermuteNonPrimary\",\n  OrientationWithoutPermutation = \"OrientationWithoutPermutation\",\n  ExperimentalOrientationWithoutPermutation2 = \"ExperimentalOrientationWithoutPermutation2\", // TODO\n}\n\nexport class PieceAnnotation<T> {\n  stickerings: Map<string, T[]> = new Map();\n  constructor(kpuzzle: KPuzzle, defaultValue: T) {\n    for (const orbitDefinition of kpuzzle.definition.orbits) {\n      this.stickerings.set(\n        orbitDefinition.orbitName,\n        new Array(orbitDefinition.numPieces).fill(defaultValue),\n      );\n    }\n  }\n}\n\nconst regular = \"regular\";\nconst ignored = \"ignored\";\nconst oriented = \"oriented\";\nconst experimentalOriented2 = \"experimentalOriented2\";\nconst invisible = \"invisible\";\nconst dim = \"dim\";\n\n// We specify 5 facelets, because that's the maximum we need for any built-in puzzles (e.g. Megaminx centers or icosa vertices).\n// TODO: use \"primary\" and \"non-primary\" fields instead of listing all non-primary facelets.\nconst pieceStickerings: Record<string, PieceStickeringMask> = {\n  // regular\n  [PieceStickering.Regular]: {\n    // r\n    facelets: [regular, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Ignored]: {\n    // i\n    facelets: [ignored, ignored, ignored, ignored, ignored],\n  },\n\n  // oriented stickers\n  [PieceStickering.OrientationStickers]: {\n    // o\n    facelets: [oriented, oriented, oriented, oriented, oriented],\n  },\n\n  // \"OLL\"\n  [PieceStickering.IgnoreNonPrimary]: {\n    // riiii\n    facelets: [regular, ignored, ignored, ignored, ignored],\n  },\n\n  // invisible\n  [PieceStickering.Invisible]: {\n    // invisiblePiece\n    facelets: [invisible, invisible, invisible, invisible, invisible],\n  },\n\n  // \"PLL\"\n  [PieceStickering.PermuteNonPrimary]: {\n    // drrrr\n    facelets: [dim, regular, regular, regular, regular],\n  },\n\n  // ignored\n  [PieceStickering.Dim]: {\n    // d\n    facelets: [dim, dim, dim, dim, dim],\n  },\n\n  // \"OLL\"\n  [PieceStickering.Ignoriented]: {\n    // diiii\n    facelets: [dim, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.OrientationWithoutPermutation]: {\n    // oiiii\n    facelets: [oriented, ignored, ignored, ignored, ignored],\n  },\n  [PieceStickering.ExperimentalOrientationWithoutPermutation2]: {\n    // oiiii\n    facelets: [experimentalOriented2, ignored, ignored, ignored, ignored],\n  },\n};\n\nexport function getPieceStickeringMask(\n  pieceStickering: PieceStickering,\n): PieceStickeringMask {\n  return pieceStickerings[pieceStickering];\n}\n\nexport class PuzzleStickering extends PieceAnnotation<PieceStickering> {\n  constructor(kpuzzle: KPuzzle) {\n    super(kpuzzle, PieceStickering.Regular);\n  }\n\n  set(pieceSet: PieceSet, pieceStickering: PieceStickering): PuzzleStickering {\n    for (const [orbitName, pieces] of this.stickerings.entries()) {\n      for (let i = 0; i < pieces.length; i++) {\n        if (pieceSet.stickerings.get(orbitName)![i]) {\n          pieces[i] = pieceStickering;\n        }\n      }\n    }\n    return this;\n  }\n\n  toStickeringMask(): StickeringMask {\n    const stickeringMask: StickeringMask = { orbits: {} };\n    for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {\n      const pieces: PieceStickeringMask[] = [];\n      const orbitStickeringMask: OrbitStickeringMask = {\n        pieces,\n      };\n      stickeringMask.orbits[orbitName] = orbitStickeringMask;\n      for (const pieceStickering of pieceStickerings) {\n        pieces.push(getPieceStickeringMask(pieceStickering));\n      }\n    }\n    return stickeringMask;\n  }\n}\n\nexport type PieceSet = PieceAnnotation<boolean>;\n\nexport class StickeringManager {\n  constructor(private kpuzzle: KPuzzle) {}\n\n  and(pieceSets: PieceSet[]): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        for (const pieceSet of pieceSets) {\n          if (!pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  or(pieceSets: PieceSet[]): PieceSet {\n    // TODO: unify impl with and?\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      pieceLoop: for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = false;\n        for (const pieceSet of pieceSets) {\n          if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n            newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n            continue pieceLoop;\n          }\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  not(pieceSet: PieceSet): PieceSet {\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] =\n          !pieceSet.stickerings.get(orbitDefinition.orbitName)![i];\n      }\n    }\n    return newPieceSet;\n  }\n\n  all(): PieceSet {\n    return this.and(this.moves([])); // TODO: are the degenerate cases for and/or the wrong way around\n  }\n\n  move(moveSource: Move | string): PieceSet {\n    const transformation = this.kpuzzle.moveToTransformation(moveSource);\n    const newPieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      for (let i = 0; i < orbitDefinition.numPieces; i++) {\n        if (\n          transformation.transformationData[orbitDefinition.orbitName]\n            .permutation[i] !== i ||\n          transformation.transformationData[orbitDefinition.orbitName]\n            .orientationDelta[i] !== 0\n        ) {\n          newPieceSet.stickerings.get(orbitDefinition.orbitName)![i] = true;\n        }\n      }\n    }\n    return newPieceSet;\n  }\n\n  moves(moveSources: (Move | string)[]): PieceSet[] {\n    return moveSources.map((moveSource) => this.move(moveSource));\n  }\n\n  orbits(orbitNames: string[]): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitName of orbitNames) {\n      pieceSet.stickerings.get(orbitName)!.fill(true);\n    }\n    return pieceSet;\n  }\n\n  orbitPrefix(orbitPrefix: string): PieceSet {\n    const pieceSet = new PieceAnnotation<boolean>(this.kpuzzle, false);\n    for (const orbitDefinition of this.kpuzzle.definition.orbits) {\n      if (orbitDefinition.orbitName.startsWith(orbitPrefix)) {\n        pieceSet.stickerings.get(orbitDefinition.orbitName)!.fill(true);\n      }\n    }\n    return pieceSet;\n  }\n  // trueCounts(pieceSet: PieceSet): Record<string, number> {\n  //   const counts: Record<string, number> = {};\n  //   for (const orbitDefinition of this.def.orbits) {\n  //     let count = 0;\n  //     for (let i = 0; i < orbitDefinition.numPieces; i++) {\n  //       if (pieceSet.stickerings.get(orbitDefinition.orbitName)![i]) {\n  //         count++;\n  //       }\n  //     }\n  //     counts[orbitName] = count;\n  //   }\n  //   return counts;\n  // }\n}\n", "import type { PuzzleID } from \"../../twisty\";\n\nconst LL = \"Last Layer\";\nconst LS = \"Last Slot\";\nconst megaAnd3x3x3LL = {\n  \"3x3x3\": LL,\n  megaminx: LL,\n};\nconst megaAnd3x3x3LS = {\n  \"3x3x3\": LS,\n  megaminx: LS,\n};\n\nexport const experimentalStickerings: Record<\n  string,\n  { groups?: Partial<Record<PuzzleID, string>> }\n> = {\n  full: { groups: { \"3x3x3\": \"Stickering\", megaminx: \"Stickering\" } }, // default\n  OLL: { groups: megaAnd3x3x3LL },\n  PLL: { groups: megaAnd3x3x3LL },\n  LL: { groups: megaAnd3x3x3LL },\n  EOLL: { groups: megaAnd3x3x3LL },\n  COLL: { groups: megaAnd3x3x3LL },\n  OCLL: { groups: megaAnd3x3x3LL },\n  CPLL: { groups: megaAnd3x3x3LL },\n  CLL: { groups: megaAnd3x3x3LL },\n  EPLL: { groups: megaAnd3x3x3LL },\n  ELL: { groups: megaAnd3x3x3LL },\n  ZBLL: { groups: megaAnd3x3x3LL },\n  LS: { groups: megaAnd3x3x3LS },\n  ELS: { groups: megaAnd3x3x3LS },\n  CLS: { groups: megaAnd3x3x3LS },\n  ZBLS: { groups: megaAnd3x3x3LS },\n  VLS: { groups: megaAnd3x3x3LS },\n  WVLS: { groups: megaAnd3x3x3LS },\n  F2L: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Daisy: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  Cross: { groups: { \"3x3x3\": \"CFOP (Fridrich)\" } },\n  EO: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOline: { groups: { \"3x3x3\": \"ZZ\" } },\n  EOcross: { groups: { \"3x3x3\": \"ZZ\" } },\n  CMLL: { groups: { \"3x3x3\": \"Roux\" } },\n  L10P: { groups: { \"3x3x3\": \"Roux\" } },\n  L6E: { groups: { \"3x3x3\": \"Roux\" } },\n  L6EO: { groups: { \"3x3x3\": \"Roux\" } },\n  \"2x2x2\": { groups: { \"3x3x3\": \"Petrus\" } },\n  \"2x2x3\": { groups: { \"3x3x3\": \"Petrus\" } },\n  G1: { groups: { \"3x3x3\": \"FMC\" } },\n  L2C: {\n    groups: {\n      \"4x4x4\": \"Reduction\",\n      \"5x5x5\": \"Reduction\",\n      \"6x6x6\": \"Reduction\",\n    },\n  },\n  PBL: {\n    groups: {\n      \"2x2x2\": \"Ortega\",\n    },\n  },\n  \"Void Cube\": { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  invisible: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  picture: { groups: { \"3x3x3\": \"Miscellaneous\" } },\n  \"centers-only\": { groups: { \"3x3x3\": \"Miscellaneous\" } }, // TODO\n  \"experimental-centers-U\": {},\n  \"experimental-centers-U-D\": {},\n  \"experimental-centers-U-L-D\": {},\n  \"experimental-centers-U-L-B-D\": {},\n  \"experimental-centers\": {},\n  \"experimental-fto-fc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-f2t\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-sc\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l2c\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-lbt\": { groups: { fto: \"Bencisco\" } },\n  \"experimental-fto-l3t\": { groups: { fto: \"Bencisco\" } },\n};\n", "import type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  type PieceSet,\n  PieceStickering,\n  type StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n} from \"./mask\";\nimport { experimentalStickerings } from \"./puzzle-stickerings\";\n\n// TODO: cache calculations?\nexport async function cubeLikeStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const LL = (): PieceSet => m.move(\"U\");\n  const orUD = (): PieceSet => m.or(m.moves([\"U\", \"D\"]));\n  const orLR = (): PieceSet => m.or(m.moves([\"L\", \"R\"]));\n  const M = (): PieceSet => m.not(orLR());\n\n  const F2L = (): PieceSet => m.not(LL());\n\n  const CENTERS = (): PieceSet => m.orbitPrefix(\"CENTER\");\n  const EDGES = (): PieceSet => m.orbitPrefix(\"EDGE\");\n  const CORNERS = (): PieceSet =>\n    m.or([\n      m.orbitPrefix(\"CORNER\"),\n      m.orbitPrefix(\"C4RNER\"),\n      m.orbitPrefix(\"C5RNER\"),\n    ]);\n\n  const L6E = (): PieceSet => m.or([M(), m.and([LL(), EDGES()])]);\n  const centerLL = (): PieceSet => m.and([LL(), CENTERS()]);\n\n  const edgeFR = (): PieceSet => m.and([m.and(m.moves([\"F\", \"R\"])), EDGES()]);\n  const cornerDFR = (): PieceSet =>\n    m.and([m.and(m.moves([\"F\", \"R\"])), CORNERS(), m.not(LL())]);\n  const slotFR = (): PieceSet => m.or([cornerDFR(), edgeFR()]);\n\n  function dimF2L(): void {\n    puzzleStickering.set(F2L(), PieceStickering.Dim);\n  }\n\n  function setPLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  function setOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.IgnoreNonPrimary);\n    puzzleStickering.set(centerLL(), PieceStickering.Regular); // For PG\n  }\n\n  function dimOLL(): void {\n    puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n    puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n  }\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"PLL\": {\n      dimF2L();\n      setPLL();\n      break;\n    }\n    case \"CLS\": {\n      dimF2L();\n      puzzleStickering.set(cornerDFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"OLL\": {\n      dimF2L();\n      setOLL();\n      break;\n    }\n    case \"EOLL\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"COLL\": {\n      dimF2L();\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"OCLL\": {\n      dimF2L();\n      dimOLL();\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"CPLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.and([CORNERS(), LL()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      puzzleStickering.set(\n        m.and([m.not(CORNERS()), LL()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"CLL\": {\n      dimF2L();\n      puzzleStickering.set(\n        m.not(m.and([CORNERS(), LL()])),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"EPLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), EDGES()]),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"ELL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.Dim);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ELS\": {\n      dimF2L();\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      puzzleStickering.set(edgeFR(), PieceStickering.Regular);\n      puzzleStickering.set(cornerDFR(), PieceStickering.Ignored);\n      break;\n    }\n    case \"LL\": {\n      dimF2L();\n      break;\n    }\n    case \"F2L\": {\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      break;\n    }\n    case \"ZBLL\": {\n      dimF2L();\n      puzzleStickering.set(LL(), PieceStickering.PermuteNonPrimary);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim); // For PG\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"ZBLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Ignored);\n      break;\n    }\n    case \"VLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      setOLL();\n      break;\n    }\n    case \"WVLS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(m.and([LL(), EDGES()]), PieceStickering.Ignoriented);\n      puzzleStickering.set(m.and([LL(), CENTERS()]), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([LL(), CORNERS()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"LS\": {\n      dimF2L();\n      puzzleStickering.set(slotFR(), PieceStickering.Regular);\n      puzzleStickering.set(LL(), PieceStickering.Ignored);\n      puzzleStickering.set(centerLL(), PieceStickering.Dim);\n      break;\n    }\n    case \"EO\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      break;\n    }\n    case \"EOline\": {\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"D\", \"M\"])), PieceStickering.Regular);\n      break;\n    }\n    case \"EOcross\": {\n      puzzleStickering.set(\n        EDGES(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.move(\"D\"), PieceStickering.Regular);\n      puzzleStickering.set(CORNERS(), PieceStickering.Ignored);\n      break;\n    }\n    case \"CMLL\": {\n      puzzleStickering.set(F2L(), PieceStickering.Dim);\n      puzzleStickering.set(L6E(), PieceStickering.Ignored);\n      puzzleStickering.set(m.and([LL(), CORNERS()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L10P\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(m.and([CORNERS(), LL()]), PieceStickering.Regular);\n      break;\n    }\n    case \"L6E\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      break;\n    }\n    case \"L6EO\": {\n      puzzleStickering.set(m.not(L6E()), PieceStickering.Dim);\n      puzzleStickering.set(\n        L6E(),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(\n        m.and([CENTERS(), orUD()]),\n        PieceStickering.OrientationStickers,\n      ); // For PG\n      break;\n    }\n    case \"Daisy\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"U\"), EDGES()]),\n        PieceStickering.IgnoreNonPrimary,\n      );\n      break;\n    }\n    case \"Cross\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(CENTERS(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), CENTERS()]),\n        PieceStickering.Regular,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"D\"), EDGES()]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"2x2x2\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      break;\n    }\n    case \"2x2x3\": {\n      puzzleStickering.set(m.all(), PieceStickering.Dim);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"F\", \"R\"])),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(\n        m.and([m.or(m.moves([\"U\", \"F\", \"R\"])), CENTERS()]),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(\n        m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"R\"])))]),\n        PieceStickering.Regular,\n      );\n      break;\n    }\n    case \"G1\": {\n      puzzleStickering.set(\n        m.all(),\n        PieceStickering.ExperimentalOrientationWithoutPermutation2,\n      );\n      puzzleStickering.set(\n        m.or(m.moves([\"E\"])),\n        PieceStickering.OrientationWithoutPermutation,\n      );\n      puzzleStickering.set(m.and(m.moves([\"E\", \"S\"])), PieceStickering.Ignored);\n      break;\n    }\n    case \"L2C\": {\n      puzzleStickering.set(\n        m.or(m.moves([\"L\", \"R\", \"B\", \"D\"])),\n        PieceStickering.Dim,\n      );\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    case \"PBL\": {\n      puzzleStickering.set(m.all(), PieceStickering.Ignored);\n      puzzleStickering.set(\n        m.or(m.moves([\"U\", \"D\"])),\n        PieceStickering.PermuteNonPrimary,\n      );\n      break;\n    }\n    case \"Void Cube\": {\n      puzzleStickering.set(CENTERS(), PieceStickering.Invisible);\n      break;\n    }\n    case \"picture\":\n    // fallthrough\n    case \"invisible\": {\n      puzzleStickering.set(m.all(), PieceStickering.Invisible);\n      break;\n    }\n    case \"centers-only\": {\n      puzzleStickering.set(m.not(CENTERS()), PieceStickering.Ignored);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function cubeLikeStickeringList(\n  puzzleID: PuzzleID,\n  options?: { use3x3x3Fallbacks: boolean },\n): Promise<ExperimentalStickering[]> {\n  const stickerings: ExperimentalStickering[] = [];\n  const stickeringsFallback: ExperimentalStickering[] = [];\n  for (const [name, info] of Object.entries(experimentalStickerings)) {\n    if (info.groups) {\n      if (puzzleID in info.groups) {\n        stickerings.push(name);\n      } else if (options?.use3x3x3Fallbacks && \"3x3x3\" in info.groups) {\n        stickeringsFallback.push(name);\n      }\n    }\n  }\n  return stickerings.concat(stickeringsFallback);\n}\n", "export function getCached<T>(getValue: () => Promise<T>): () => Promise<T> {\n  let cachedPromise: Promise<T> | null = null;\n  return (): Promise<T> => {\n    return (cachedPromise ??= getValue());\n  };\n}\n", "// @ts-nocheck\n\nexport class PLazy<T> extends Promise<T> {\n  constructor(executor) {\n    super((resolve) => {\n      resolve();\n    });\n\n    this._executor = executor;\n  }\n\n  static from(function_) {\n    return new PLazy((resolve) => {\n      resolve(function_());\n    });\n  }\n\n  static resolve(value) {\n    return new PLazy((resolve) => {\n      resolve(value);\n    });\n  }\n\n  static reject(error) {\n    return new PLazy((_resolve, reject) => {\n      reject(error);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    this._promise = this._promise || new Promise(this._executor);\n\n    return this._promise.catch(onRejected);\n  }\n}\n\nexport function from<T>(function_): Promise<T> {\n  return new PLazy((resolve) => {\n    resolve(function_());\n  });\n}\n", "import { KPuzzle, type KPuzzleDefinition } from \"../../kpuzzle\";\nimport type { PuzzleGeometry } from \"../../puzzle-geometry\";\nimport type { ExperimentalStickering, PuzzleID } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"../stickerings/mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../stickerings/cube-like-stickerings\";\nimport { getCached } from \"./lazy-cached\";\nimport {\n  Move,\n  type PuzzleSpecificSimplifyOptions,\n  QuantumMove,\n} from \"../../alg\";\nimport { PLazy } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function asyncGetPuzzleGeometry(\n  puzzleName: string,\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n  });\n}\n\n// TODO: can we cache the puzzleGeometry to avoid duplicate calls, without\n// wasting memory? Maybe just save the latest one for successive calls about the\n// same puzzle?\nexport async function asyncGetKPuzzle(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): Promise<KPuzzle> {\n  const pg = await pgPromise;\n  const kpuzzleDefinition: KPuzzleDefinition = pg.getKPuzzleDefinition(true);\n  kpuzzleDefinition.name = puzzleName;\n  const puzzleGeometry = await import(\"../../puzzle-geometry\");\n  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(\n    pg,\n    pg.getOrbitsDef(true),\n  );\n  return new KPuzzle(pgNotation.remapKPuzzleDefinition(kpuzzleDefinition), {\n    experimentalPGNotation: pgNotation,\n  });\n}\n\nexport function asyncLazyKPuzzleGetter(\n  pgPromise: Promise<PuzzleGeometry>,\n  puzzleName: string,\n): () => Promise<KPuzzle> {\n  return getCached(() => asyncGetKPuzzle(pgPromise, puzzleName));\n}\n\ntype PuzzleLoaderConstructorArgs = {\n  pgID?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n};\n\nexport class PGPuzzleLoader implements PuzzleLoader {\n  pgId?: string;\n  id: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number;\n  constructor(info: PuzzleLoaderConstructorArgs) {\n    this.pgId = info.pgID;\n    this.id = info.id;\n    this.fullName = info.fullName;\n    this.inventedBy = info.inventedBy;\n    this.inventionYear = info.inventionYear;\n  }\n\n  #cachedPG: Promise<PuzzleGeometry> | undefined;\n  pg(): Promise<PuzzleGeometry> {\n    return (this.#cachedPG ??= asyncGetPuzzleGeometry(this.pgId ?? this.id));\n  }\n\n  #cachedKPuzzle: Promise<KPuzzle> | undefined;\n  kpuzzle(): Promise<KPuzzle> {\n    return (this.#cachedKPuzzle ??= asyncGetKPuzzle(this.pg(), this.id));\n  }\n\n  #cachedSVG: Promise<string> | undefined;\n  svg(): Promise<string> {\n    return (this.#cachedSVG ??= (async () =>\n      (await this.pg()).generatesvg())());\n  }\n\n  puzzleSpecificSimplifyOptionsPromise = puzzleSpecificSimplifyOptionsPromise(\n    this.kpuzzle.bind(this),\n  );\n}\n\nexport class CubePGPuzzleLoader extends PGPuzzleLoader {\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return cubeLikeStickeringMask(this, stickering);\n  }\n  stickerings = () =>\n    cubeLikeStickeringList(this.id as PuzzleID, { use3x3x3Fallbacks: true });\n}\n\nexport function puzzleSpecificSimplifyOptionsPromise(\n  kpuzzlePromiseFn: () => Promise<KPuzzle>,\n): Promise<PuzzleSpecificSimplifyOptions> {\n  return new PLazy(\n    async (resolve: (options: PuzzleSpecificSimplifyOptions) => void) => {\n      const kpuzzle = await kpuzzlePromiseFn();\n      resolve({\n        quantumMoveOrder: (m: QuantumMove) => {\n          return kpuzzle.moveToTransformation(new Move(m)).repetitionOrder();\n        },\n      });\n    },\n  );\n}\n", "import type { KPuzzleDefinition } from \"../../../../kpuzzle\";\n\nexport const cube3x3x3KPuzzleDefinition: KPuzzleDefinition = {\n  name: \"3x3x3\",\n  orbits: [\n    { orbitName: \"EDGES\", numPieces: 12, numOrientations: 2 },\n    { orbitName: \"CORNERS\", numPieces: 8, numOrientations: 3 },\n    { orbitName: \"CENTERS\", numPieces: 6, numOrientations: 4 },\n  ],\n  defaultPattern: {\n    EDGES: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CORNERS: {\n      pieces: [0, 1, 2, 3, 4, 5, 6, 7],\n      orientation: [0, 0, 0, 0, 0, 0, 0, 0],\n    },\n    CENTERS: {\n      pieces: [0, 1, 2, 3, 4, 5],\n      orientation: [0, 0, 0, 0, 0, 0],\n      orientationMod: [1, 1, 1, 1, 1, 1],\n    },\n  },\n  moves: {\n    U: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    y: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 7, 4, 5, 6],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 3],\n      },\n    },\n    x: {\n      EDGES: {\n        permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 3, 5, 7, 6, 2, 1],\n        orientationDelta: [2, 1, 2, 1, 1, 2, 1, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 3, 0, 1, 2, 2],\n      },\n    },\n    L: {\n      EDGES: {\n        permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 1, 0, 0, 0, 0],\n      },\n    },\n    F: {\n      EDGES: {\n        permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],\n        orientationDelta: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 1, 0, 0, 0],\n      },\n    },\n    R: {\n      EDGES: {\n        permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 1, 0, 0],\n      },\n    },\n    B: {\n      EDGES: {\n        permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],\n        orientationDelta: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 1, 0],\n      },\n    },\n    D: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 1, 2, 3, 4, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n    z: {\n      EDGES: {\n        permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],\n        orientationDelta: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [3, 2, 6, 5, 0, 4, 7, 1],\n        orientationDelta: [1, 2, 1, 2, 2, 1, 2, 1],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 3, 1],\n      },\n    },\n    M: {\n      EDGES: {\n        permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 0, 0, 0, 2, 0],\n      },\n    },\n    E: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 0],\n      },\n    },\n    S: {\n      EDGES: {\n        permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],\n        orientationDelta: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 0, 1, 0, 1],\n      },\n    },\n    u: {\n      EDGES: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [1, 2, 3, 0, 4, 5, 6, 7],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 2, 3, 4, 1, 5],\n        orientationDelta: [1, 0, 0, 0, 0, 0],\n      },\n    },\n    l: {\n      EDGES: {\n        permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [0, 1, 6, 2, 4, 3, 5, 7],\n        orientationDelta: [0, 0, 2, 1, 0, 2, 1, 0],\n      },\n      CENTERS: {\n        permutation: [4, 1, 0, 3, 5, 2],\n        orientationDelta: [2, 1, 0, 0, 2, 0],\n      },\n    },\n    f: {\n      EDGES: {\n        permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],\n        orientationDelta: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\n      },\n      CORNERS: {\n        permutation: [3, 1, 2, 5, 0, 4, 6, 7],\n        orientationDelta: [1, 0, 0, 2, 2, 1, 0, 0],\n      },\n      CENTERS: {\n        permutation: [1, 5, 2, 0, 4, 3],\n        orientationDelta: [1, 1, 1, 1, 0, 1],\n      },\n    },\n    r: {\n      EDGES: {\n        permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],\n        orientationDelta: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],\n      },\n      CORNERS: {\n        permutation: [4, 0, 2, 3, 7, 5, 6, 1],\n        orientationDelta: [2, 1, 0, 0, 1, 0, 0, 2],\n      },\n      CENTERS: {\n        permutation: [2, 1, 5, 3, 0, 4],\n        orientationDelta: [0, 0, 0, 1, 2, 2],\n      },\n    },\n    b: {\n      EDGES: {\n        permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],\n        orientationDelta: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 7, 1, 3, 4, 5, 2, 6],\n        orientationDelta: [0, 2, 1, 0, 0, 0, 2, 1],\n      },\n      CENTERS: {\n        permutation: [3, 0, 2, 5, 4, 1],\n        orientationDelta: [3, 3, 0, 3, 1, 3],\n      },\n    },\n    d: {\n      EDGES: {\n        permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1],\n      },\n      CORNERS: {\n        permutation: [0, 1, 2, 3, 5, 6, 7, 4],\n        orientationDelta: [0, 0, 0, 0, 0, 0, 0, 0],\n      },\n      CENTERS: {\n        permutation: [0, 4, 1, 2, 3, 5],\n        orientationDelta: [0, 0, 0, 0, 0, 1],\n      },\n    },\n  },\n  derivedMoves: {\n    Uw: \"u\",\n    Lw: \"l\",\n    Fw: \"f\",\n    Rw: \"r\",\n    Bw: \"b\",\n    Dw: \"d\",\n\n    Uv: \"y\",\n    Lv: \"x'\",\n    Fv: \"z\",\n    Rv: \"x\",\n    Bv: \"z'\",\n    Dv: \"y'\",\n\n    \"2U\": \"u U'\",\n    \"2L\": \"l L'\",\n    \"2F\": \"f F'\",\n    \"2R\": \"r R'\",\n    \"2B\": \"b B'\",\n    \"2D\": \"d D'\",\n  },\n};\n", "import type { PuzzleSpecificSimplifyOptions } from \"../alg\";\nimport type { AppendOptions } from \"../alg/simplify\";\nimport type { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { ExperimentalStickering } from \"../twisty\";\nimport type { StickeringMask } from \"./stickerings/mask\";\n\nexport interface PuzzleLoader {\n  id: string;\n  // shortName?: string;\n  fullName: string;\n  inventedBy?: string[];\n  inventionYear?: number; // TODO: date?\n  /** @deprecated */\n  def?: never;\n  kpuzzle: () => Promise<KPuzzle>; // TODO\n  svg: () => Promise<string>;\n  llSVG?: () => Promise<string>;\n  llFaceSVG?: () => Promise<string>;\n  pg?: () => Promise<PuzzleGeometry>;\n  stickeringMask?: (\n    stickering: ExperimentalStickering,\n  ) => Promise<StickeringMask>;\n  stickerings?: () => Promise<ExperimentalStickering[]>;\n  puzzleSpecificSimplifyOptions?: PuzzleSpecificSimplifyOptions;\n  puzzleSpecificSimplifyOptionsPromise?: Promise<PuzzleSpecificSimplifyOptions>; // TODO\n}\n\n// TODO: consolidate the `puzzleSpecificSimplifyOptionsPromise` with `puzzleSpecificSimplifyOptions` somehow, so that we don't have to do this.\nexport async function getPartialAppendOptionsForPuzzleSpecificSimplifyOptions(\n  puzzleLoader: PuzzleLoader,\n): Promise<AppendOptions> {\n  const puzzleSpecificSimplifyOptions =\n    await (puzzleLoader.puzzleSpecificSimplifyOptions ??\n      puzzleLoader.puzzleSpecificSimplifyOptionsPromise);\n  if (!puzzleSpecificSimplifyOptions) {\n    return {};\n  }\n  return { puzzleLoader: { puzzleSpecificSimplifyOptions } };\n}\n", "import { Alg } from \"../../../../alg\";\nimport type { KPuzzle, KPattern, KTransformation } from \"../../../../kpuzzle\";\n\nexport function puzzleOrientation2x2x2Idx(pattern: KPattern): number {\n  const inverse = pattern.experimentalToTransformation()!.invert();\n\n  const inverseDFL = inverse.transformationData[\"CORNERS\"];\n  return inverseDFL.permutation[6] * 3 + inverseDFL.orientationDelta[6];\n}\n\nconst puzzleOrientationCacheRaw: {\n  transformation: KTransformation;\n  alg: Alg;\n}[] = new Array<KTransformation>(24) as any;\n\nconst puzzleOrientationCacheInitialized = false;\n// We rely on the (first) caller to pass in the `KPuzzle`, so that we don't need to get our own synchronous reference.\nexport function puzzleOrientation2x2x2Cache(\n  kpuzzle: KPuzzle,\n): typeof puzzleOrientationCacheRaw {\n  if (!puzzleOrientationCacheInitialized) {\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = kpuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const idx = puzzleOrientation2x2x2Idx(transformation.toKPattern());\n          puzzleOrientationCacheRaw[idx] = {\n            transformation: transformation.invert(),\n            alg: uAlg.concat(yAlg),\n          };\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize2x2x2Orientation(pattern: KPattern): {\n  normalizedPattern: KPattern;\n  normalizationAlg: Alg;\n} {\n  const idx = puzzleOrientation2x2x2Idx(pattern);\n  const { transformation, alg } = puzzleOrientation2x2x2Cache(pattern.kpuzzle)[\n    idx\n  ];\n  return {\n    normalizedPattern: pattern.applyTransformation(transformation),\n    normalizationAlg: alg.invert(),\n  };\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs2x2x2Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize2x2x2Orientation(pattern).normalizedPattern;\n  }\n  return !!pattern.experimentalToTransformation()!.isIdentityTransformation(); // TODO: Compare to start pattern instead?\n}\n", "import { KPuzzle } from \"../kpuzzle\";\nimport type { PuzzleGeometry } from \"../puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"../puzzle-geometry/PGPuzzles\";\nimport {\n  asyncGetKPuzzle,\n  puzzleSpecificSimplifyOptionsPromise,\n} from \"./async/async-pg3d\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\n\n// TODO: modify this to handle TwistyPlayer options\nexport async function descAsyncGetPuzzleGeometry(\n  desc: PuzzleDescriptionString,\n  options?: { includeCenterOrbits?: boolean; includeEdgeOrbits?: boolean },\n): Promise<PuzzleGeometry> {\n  const puzzleGeometry = await import(\"../puzzle-geometry\");\n  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {\n    allMoves: true,\n    orientCenters: true,\n    addRotations: true,\n    ...options,\n  });\n}\n\nexport async function asyncGetKPuzzleByDesc(\n  desc: PuzzleDescriptionString,\n  options?: { includeCenterOrbits?: boolean; includeEdgeOrbits?: boolean },\n): Promise<KPuzzle> {\n  const pgPromise = descAsyncGetPuzzleGeometry(desc, options);\n  return asyncGetKPuzzle(pgPromise, `description: ${desc}`);\n}\n\n// TODO: Can we avoid relying on IDs to deduplicate work at higher levels?\nlet nextCustomID = 1;\n\nexport function customPGPuzzleLoader(\n  desc: PuzzleDescriptionString,\n  info?: {\n    fullName?: string;\n    inventedBy?: string[];\n    inventionYear?: number;\n  },\n): PuzzleLoader {\n  const customID = nextCustomID++;\n  let cachedKPuzzle: Promise<KPuzzle> | null = null;\n  const kpuzzlePromiseFn = async () => {\n    return (cachedKPuzzle ??= asyncGetKPuzzleByDesc(desc));\n  };\n  const puzzleLoader: PuzzleLoader = {\n    id: `custom-${customID}`,\n    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,\n    kpuzzle: kpuzzlePromiseFn,\n    svg: async () => {\n      const pg = await descAsyncGetPuzzleGeometry(desc);\n      return pg.generatesvg();\n    },\n    pg: async () => {\n      return descAsyncGetPuzzleGeometry(desc);\n    },\n    puzzleSpecificSimplifyOptionsPromise:\n      puzzleSpecificSimplifyOptionsPromise(kpuzzlePromiseFn),\n  };\n  if (info?.inventedBy) {\n    puzzleLoader.inventedBy = info.inventedBy;\n  }\n  if (info?.inventionYear) {\n    puzzleLoader.inventionYear = info.inventionYear;\n  }\n  return puzzleLoader;\n}\n", "import { KPuzzle } from \"../../kpuzzle\";\nimport { cube3x3x3KPuzzleDefinition as experimentalCube3x3x3KPuzzleDefinition } from \"../implementations/dynamic/3x3x3/3x3x3.kpuzzle.json\";\nimport { experimentalIs3x3x3Solved } from \"../implementations/dynamic/3x3x3/puzzle-orientation\";\nexport { getPartialAppendOptionsForPuzzleSpecificSimplifyOptions } from \"../PuzzleLoader\";\nexport { experimentalCube3x3x3KPuzzleDefinition };\n\n/** @deprecated */\nexport const experimental3x3x3KPuzzle = new KPuzzle(\n  experimentalCube3x3x3KPuzzleDefinition,\n);\nexperimentalCube3x3x3KPuzzleDefinition.experimentalIsPatternSolved =\n  experimentalIs3x3x3Solved;\n\nexport {\n  experimentalIs3x3x3Solved,\n  normalize3x3x3Orientation as experimentalNormalize3x3x3Orientation,\n  puzzleOrientation3x3x3Cache as experimentalPuzzleOrientation3x3x3Cache,\n  puzzleOrientation3x3x3Idx as experimentalPuzzleOrientation3x3x3Idx,\n} from \"../implementations/dynamic/3x3x3/puzzle-orientation\"; // TODO: Actually dynamic\nexport { experimentalStickerings } from \"../stickerings/puzzle-stickerings\";\n\nexport {\n  experimentalIs2x2x2Solved,\n  normalize2x2x2Orientation as experimentalNormalize2x2x2Orientation,\n  puzzleOrientation2x2x2Cache as experimentalPuzzleOrientation2x2x2Cache,\n  puzzleOrientation2x2x2Idx as experimentalPuzzleOrientation2x2x2Idx,\n} from \"../implementations/dynamic/2x2x2/puzzle-orientation\"; // TODO: Actually dynamic\n\nexport { customPGPuzzleLoader as experimentalCustomPGPuzzleLoader } from \"../customPGPuzzleLoader\";\nexport { getFaceletStickeringMask as experimentalGetFaceletStickeringMask } from \"../stickerings/mask\";\nexport type {\n  PieceStickeringMask as ExperimentalPieceStickeringMask,\n  FaceletMeshStickeringMask as ExperimentalFaceletMeshStickeringMask,\n  StickeringMask as ExperimentalStickeringMask,\n} from \"../stickerings/mask\";\nexport {\n  getPieceStickeringMask as experimentalGetPieceStickeringMask,\n  PieceStickering as ExperimentalPieceStickering,\n} from \"../stickerings/mask\";\n", "import { Alg } from \"../../../../alg\";\nimport { KPattern, KTransformation } from \"../../../../kpuzzle\";\nimport { experimental3x3x3KPuzzle } from \"../../../cubing-private\";\n\nexport function puzzleOrientation3x3x3Idx(pattern: KPattern): [number, number] {\n  const idxU = pattern.patternData[\"CENTERS\"].pieces[0];\n  const idxD = pattern.patternData[\"CENTERS\"].pieces[5];\n  const unadjustedIdxL = pattern.patternData[\"CENTERS\"].pieces[1];\n  let idxL = unadjustedIdxL;\n  if (idxU < unadjustedIdxL) {\n    idxL--;\n  }\n  if (idxD < unadjustedIdxL) {\n    idxL--;\n  }\n  return [idxU, idxL];\n}\n\nconst puzzleOrientationCacheRaw: KTransformation[][] = new Array(6)\n  .fill(0)\n  .map(() => {\n    return new Array<KTransformation>(6);\n  });\n\nconst puzzleOrientationCacheInitialized = false;\nexport function puzzleOrientation3x3x3Cache(): KTransformation[][] {\n  if (!puzzleOrientationCacheInitialized) {\n    // We use a new block to avoid keeping a reference to temporary vars.\n    // kpuzzle todo\n    {\n      const uAlgs: Alg[] = [\"\", \"z\", \"x\", \"z'\", \"x'\", \"x2\"].map((s) =>\n        Alg.fromString(s),\n      );\n      const yAlg = new Alg(\"y\");\n      for (const uAlg of uAlgs) {\n        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);\n        for (let i = 0; i < 4; i++) {\n          transformation = transformation.applyAlg(yAlg);\n          const [idxU, idxL] = puzzleOrientation3x3x3Idx(\n            transformation.toKPattern(),\n          );\n          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();\n        }\n      }\n    }\n  }\n  return puzzleOrientationCacheRaw;\n}\n\nexport function normalize3x3x3Orientation(pattern: KPattern): KPattern {\n  const [idxU, idxL] = puzzleOrientation3x3x3Idx(pattern);\n  const orientationTransformation = puzzleOrientation3x3x3Cache()[idxU][idxL];\n  return pattern.applyTransformation(orientationTransformation);\n}\n\n// The `options` argument is required for now, because we haven't yet come up\n// with a general way to specify different kinds of solved for the same puzle.\nexport function experimentalIs3x3x3Solved(\n  pattern: KPattern,\n  options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  },\n): boolean {\n  if (options.ignorePuzzleOrientation) {\n    pattern = normalize3x3x3Orientation(pattern);\n  }\n  // TODO(orientationMod)\n  if (options.ignoreCenterOrientation) {\n    pattern = new KPattern(pattern.kpuzzle, {\n      EDGES: pattern.patternData.EDGES,\n      CORNERS: pattern.patternData.CORNERS,\n      CENTERS: {\n        pieces: pattern.patternData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    });\n  }\n  return !!pattern.experimentalToTransformation()?.isIdentityTransformation(); // TODO: Compare to start state instead?\n}\n", "import type { PuzzleID } from \"../twisty\";\n\ninterface EventInfo {\n  puzzleID: PuzzleID;\n  eventName: string;\n}\n\nexport const wcaEvents: Record<string, EventInfo> = {\n  \"333\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Cube\" },\n  \"222\": { puzzleID: \"2x2x2\", eventName: \"2x2x2 Cube\" },\n  \"444\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Cube\" },\n  \"555\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Cube\" },\n  \"666\": { puzzleID: \"6x6x6\", eventName: \"6x6x6 Cube\" },\n  \"777\": { puzzleID: \"7x7x7\", eventName: \"7x7x7 Cube\" },\n  \"333bf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Blindfolded\" },\n  \"333fm\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Fewest Moves\" },\n  \"333oh\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 One-Handed\" },\n  clock: { puzzleID: \"clock\", eventName: \"Clock\" },\n  minx: { puzzleID: \"megaminx\", eventName: \"Megaminx\" },\n  pyram: { puzzleID: \"pyraminx\", eventName: \"Pyraminx\" },\n  skewb: { puzzleID: \"skewb\", eventName: \"Skewb\" },\n  sq1: { puzzleID: \"square1\", eventName: \"Square-1\" },\n  \"444bf\": { puzzleID: \"4x4x4\", eventName: \"4x4x4 Blindfolded\" },\n  \"555bf\": { puzzleID: \"5x5x5\", eventName: \"5x5x5 Blindfolded\" },\n  \"333mbf\": { puzzleID: \"3x3x3\", eventName: \"3x3x3 Multi-Blind\" },\n};\n\n/** @category Event Info */\nexport function wcaEventInfo(event: string): EventInfo | null {\n  return wcaEvents[event] ?? null;\n}\n\nexport const twizzleEvents: Record<string, EventInfo> = {\n  ...wcaEvents,\n  fto: { puzzleID: \"fto\", eventName: \"Face-Turning Octahedron\" },\n  master_tetraminx: {\n    puzzleID: \"master_tetraminx\",\n    eventName: \"Master Tetraminx\",\n  },\n  kilominx: {\n    puzzleID: \"kilominx\",\n    eventName: \"Kilominx\",\n  },\n  redi_cube: {\n    puzzleID: \"redi_cube\",\n    eventName: \"Redi Cube\",\n  },\n  loopover: {\n    puzzleID: \"loopover\",\n    eventName: \"Loopover\",\n  },\n};\n\n/** @category Event Info */\nexport function eventInfo(event: string): EventInfo | null {\n  return twizzleEvents[event] ?? null;\n}\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"../../stickerings/cube-like-stickerings\";\n\n/** @category Specific Puzzles */\nexport const cube2x2x2: PuzzleLoader = {\n  id: \"2x2x2\",\n  fullName: \"2\u00D72\u00D72 Cube\",\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .cube2x2x2JSON,\n      ),\n  ),\n  svg: async () =>\n    (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .cube2x2x2SVG,\n  llSVG: getCached(\n    async () =>\n      (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n        .cube2x2x2LLSVG,\n  ),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"2x2x2\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube2x2x2, stickering),\n  stickerings: () =>\n    cubeLikeStickeringList(\"2x2x2\", { use3x3x3Fallbacks: true }),\n};\n", "import type { PuzzleSpecificSimplifyOptions } from \"../../../alg\";\nimport { Move, QuantumMove } from \"../../../alg\";\n\nenum Axis {\n  X = \"x axis\",\n  Y = \"y axis\",\n  Z = \"z axis\",\n}\n\nenum MoveSourceType {\n  INDEXABLE_SLICE_NEAR,\n  INDEXABLE_SLICE_FAR,\n  INDEXABLE_WIDE_NEAR,\n  INDEXABLE_WIDE_FAR,\n  SPECIFIC_SLICE,\n  ROTATION,\n}\n\ninterface MoveSourceInfo {\n  family: string;\n  direction: -1 | 1;\n  type: MoveSourceType;\n  from: number;\n  to: number;\n}\n\nfunction makeSourceInfo(\n  moveStrings: string[],\n  type: MoveSourceType,\n  from: number,\n  to: number,\n): MoveSourceInfo[] {\n  const output: MoveSourceInfo[] = [];\n  for (const moveString of moveStrings) {\n    const move = Move.fromString(moveString);\n    const { family, amount: direction } = move;\n    if (![-1, 1].includes(direction)) {\n      // TODO: test iner/outer\n      // TODO: Can we move this to a test file?\n      throw new Error(\"Invalid config move\");\n    }\n    output.push({ family, direction: direction as -1 | 1, type, from, to });\n  }\n  return output;\n}\n\ninterface AxisInfo {\n  sliceDiameter: number;\n  extendsThroughEntirePuzzle: boolean;\n  moveSourceInfos: MoveSourceInfo[];\n}\n\n// TODO: wide slices\nconst axisInfos: Record<Axis, AxisInfo> = {\n  [Axis.X]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"R\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"L'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"r\", \"Rw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"l'\", \"Lw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"M'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"x\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Y]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"U\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"D'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"u\", \"Uw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 2),\n      ...makeSourceInfo([\"d'\", \"Dw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 2),\n      ...makeSourceInfo([\"E'\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"y\", \"Uv\", \"Dv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n  [Axis.Z]: {\n    sliceDiameter: 3,\n    extendsThroughEntirePuzzle: true,\n    moveSourceInfos: [\n      ...makeSourceInfo([\"F\"], MoveSourceType.INDEXABLE_SLICE_NEAR, 0, 3),\n      ...makeSourceInfo([\"B'\"], MoveSourceType.INDEXABLE_SLICE_FAR, 0, 3),\n      ...makeSourceInfo([\"f\", \"Fw\"], MoveSourceType.INDEXABLE_WIDE_NEAR, 0, 3),\n      ...makeSourceInfo([\"b'\", \"Bw'\"], MoveSourceType.INDEXABLE_WIDE_FAR, 0, 3),\n      ...makeSourceInfo([\"S\"], MoveSourceType.SPECIFIC_SLICE, 1, 2), // TODO: remove some indices?\n      ...makeSourceInfo([\"z\", \"Fv\", \"Bv'\"], MoveSourceType.ROTATION, 0, 3), // TODO: remove some indices?\n    ],\n  },\n};\n\nconst byFamily: Record<string, { axis: Axis; moveSourceInfo: MoveSourceInfo }> =\n  {};\nfor (const [axis, info] of Object.entries(axisInfos)) {\n  for (const moveSourceInfo of info.moveSourceInfos) {\n    byFamily[moveSourceInfo.family] = { axis: axis as Axis, moveSourceInfo };\n  }\n}\n\n// TODO: lazy initialization?\nconst byAxisThenType: Record<\n  Axis,\n  Partial<Record<MoveSourceType, MoveSourceInfo[]>>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Partial<Record<MoveSourceType, MoveSourceInfo[]>> = {};\n  byAxisThenType[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    (entry[moveSourceInfo.type] ??= []).push(moveSourceInfo);\n  }\n}\n\n// TODO: consolidate lookup tables?\nconst byAxisThenSpecificSlices: Record<\n  Axis,\n  Map<number, MoveSourceInfo>\n> = {} as any; // TODO: avoid typecast (using `Object.fromEntries`?)\nfor (const axis of Object.keys(axisInfos) as Axis[]) {\n  const entry: Map<number, MoveSourceInfo> = new Map();\n  byAxisThenSpecificSlices[axis] = entry;\n  for (const moveSourceInfo of axisInfos[axis].moveSourceInfos) {\n    // We only want to use the first entry per slice index (in the unlikely case there are multiple).\n    if (!entry.get(moveSourceInfo.from)) {\n      entry.set(moveSourceInfo.from, moveSourceInfo);\n    }\n  }\n}\n\nfunction firstOfType(\n  axis: Axis,\n  moveSourceType: MoveSourceType,\n): MoveSourceInfo {\n  const entry = byAxisThenType[axis][moveSourceType]?.[0];\n  if (!entry) {\n    throw new Error(\n      `Could not find a reference move (axis: ${axis}, move source type: ${moveSourceType})`,\n    );\n  }\n  return entry;\n}\n\nconst areQuantumMovesSameAxis = (\n  quantumMove1: QuantumMove,\n  quantumMove2: QuantumMove,\n) => {\n  return (\n    byFamily[quantumMove1.family].axis === byFamily[quantumMove2.family].axis\n  );\n};\n\nfunction simplestMove(\n  axis: Axis,\n  from: number,\n  to: number,\n  directedAmount: number,\n): Move {\n  if (from + 1 === to) {\n    const sliceSpecificInfo = byAxisThenSpecificSlices[axis].get(from);\n    if (sliceSpecificInfo) {\n      return new Move(\n        new QuantumMove(sliceSpecificInfo.family),\n        directedAmount * sliceSpecificInfo.direction,\n      );\n    }\n  }\n\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  if (from === 0 && to === sliceDiameter) {\n    const moveSourceInfo = firstOfType(axis, MoveSourceType.ROTATION);\n    return new Move(\n      new QuantumMove(moveSourceInfo.family),\n      directedAmount * moveSourceInfo.direction,\n    );\n  }\n\n  // const specificSliceInfo = byAxisThenSpecificSlices[axis].get(from);\n  const far = from + to > sliceDiameter; // (from + to) / 2 > sliceDiameter / 2\n  if (far) {\n    [from, to] = [sliceDiameter - to, sliceDiameter - from];\n  }\n\n  let outerLayer: number | null = from + 1; // change to 1-indexed\n  let innerLayer: number | null = to; // already 1-indexed\n  const slice = outerLayer === innerLayer;\n  if (slice) {\n    innerLayer = null;\n  }\n\n  if (outerLayer === 1) {\n    outerLayer = null;\n  }\n  if (slice && outerLayer === 1) {\n    innerLayer = null;\n  }\n  if (!slice && innerLayer === 2) {\n    innerLayer = null;\n  }\n\n  const moveSourceType = slice\n    ? far\n      ? MoveSourceType.INDEXABLE_SLICE_FAR\n      : MoveSourceType.INDEXABLE_SLICE_NEAR\n    : far\n      ? MoveSourceType.INDEXABLE_WIDE_FAR\n      : MoveSourceType.INDEXABLE_WIDE_NEAR;\n  const moveSourceInfo = firstOfType(axis, moveSourceType);\n  return new Move(\n    new QuantumMove(moveSourceInfo.family, innerLayer, outerLayer),\n    directedAmount * moveSourceInfo.direction,\n  );\n}\n\nfunction simplifySameAxisMoves(\n  moves: Move[],\n  quantumMod: boolean = true, // TODO\n): Move[] {\n  if (moves.length === 0) {\n    // TODO: can we use the type system to avoid this?\n    return [];\n  }\n\n  const axis: Axis = byFamily[moves[0].family].axis;\n  const axisInfo = axisInfos[axis];\n  const { sliceDiameter } = axisInfo;\n  const sliceDeltas = new Map<number, number>();\n  let lastCandidateRange: {\n    suffixLength: number;\n    sliceDeltas: Map<number, number>;\n  } | null = null;\n\n  function adjustValue(idx: number, relativeDelta: number) {\n    let newDelta = (sliceDeltas.get(idx) ?? 0) + relativeDelta;\n    if (quantumMod) {\n      newDelta = (newDelta % 4) + (5 % 4) - 1; // TODO: Use a passed-in `modMove`?\n    }\n    if (newDelta === 0) {\n      sliceDeltas.delete(idx);\n    } else {\n      sliceDeltas.set(idx, newDelta);\n    }\n  }\n  // TODO: go as far as possible instead of trying to take all moves, e.g. simplify U y y' to U.\n  let suffixLength = 0;\n  // TODO: Reverse iterator?\n  for (const move of Array.from(moves).reverse()) {\n    suffixLength++;\n    const { moveSourceInfo } = byFamily[move.family];\n    const directedAmount = move.amount * moveSourceInfo.direction;\n    // console.log({ directedAmount });\n    switch (moveSourceInfo.type) {\n      case MoveSourceType.INDEXABLE_SLICE_NEAR: {\n        // We convert to zero-indexing\n        const idx = (move.innerLayer ?? 1) - 1;\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_SLICE_FAR: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        const idx = sliceDiameter - (move.innerLayer ?? 1);\n        adjustValue(idx, directedAmount);\n        adjustValue(idx + 1, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_NEAR: {\n        adjustValue((move.outerLayer ?? 1) - 1, directedAmount);\n        adjustValue(move.innerLayer ?? 2, -directedAmount);\n        break;\n      }\n      case MoveSourceType.INDEXABLE_WIDE_FAR: {\n        adjustValue(sliceDiameter - (move.innerLayer ?? 2), directedAmount);\n        adjustValue(\n          sliceDiameter - ((move.outerLayer ?? 1) - 1),\n          -directedAmount,\n        );\n        break;\n      }\n      case MoveSourceType.SPECIFIC_SLICE: {\n        // We convert to zero-indexing (which cancels with the subtraction from the slice width)\n        adjustValue(moveSourceInfo.from, directedAmount);\n        adjustValue(moveSourceInfo.to, -directedAmount);\n        break;\n      }\n      case MoveSourceType.ROTATION: {\n        adjustValue(0, directedAmount);\n        adjustValue(sliceDiameter, -directedAmount);\n        break;\n      }\n    }\n    if ([0, 2].includes(sliceDeltas.size)) {\n      lastCandidateRange = { suffixLength, sliceDeltas: new Map(sliceDeltas) };\n    }\n  }\n  if (sliceDeltas.size === 0) {\n    return [];\n  }\n  // TODO: handle this check in the destructuring assignment?\n  if (!lastCandidateRange) {\n    return moves;\n  }\n  let [from, to] = lastCandidateRange.sliceDeltas.keys();\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n  const directedAmount = lastCandidateRange.sliceDeltas.get(from)!;\n  // TODO: Handle empty move\n  return [\n    ...moves.slice(0, -lastCandidateRange.suffixLength),\n    ...(directedAmount !== 0\n      ? [simplestMove(axis, from, to, directedAmount)]\n      : []),\n  ];\n}\n\nexport const puzzleSpecificSimplifyOptions333: PuzzleSpecificSimplifyOptions = {\n  quantumMoveOrder: () => 4,\n  // doQuantumMovesCommute: areQuantumMovesSameAxis,\n  axis: { areQuantumMovesSameAxis, simplifySameAxisMoves },\n};\n", "// Include 3x3x3 in the main bundle for better performance.\nimport type { ExperimentalStickering } from \"../../../twisty\";\nimport { asyncGetPuzzleGeometry } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport { experimental3x3x3KPuzzle } from \"../../cubing-private\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  cubeLikeStickeringMask,\n  cubeLikeStickeringList,\n} from \"../../stickerings/cube-like-stickerings\";\nimport { puzzleSpecificSimplifyOptions333 } from \"./puzzle-specific-simplifications\";\n\n/** @category Specific Puzzles */\nexport const cube3x3x3 = {\n  id: \"3x3x3\",\n  fullName: \"3\u00D73\u00D73 Cube\",\n  inventedBy: [\"Ern\u0151 Rubik\"],\n  inventionYear: 1974, // https://en.wikipedia.org/wiki/Rubik%27s_Cube#Conception_and_development\n  kpuzzle: getCached(async () => {\n    return experimental3x3x3KPuzzle;\n  }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3SVG;\n  }),\n  llSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLSVG;\n  }),\n  llFaceSVG: getCached(async () => {\n    return (await import(\"../dynamic/3x3x3/puzzles-dynamic-3x3x3\"))\n      .cube3x3x3LLFaceSVG;\n  }),\n  pg: getCached(async () => {\n    return asyncGetPuzzleGeometry(\"3x3x3\");\n  }),\n  stickeringMask: (\n    stickering: ExperimentalStickering,\n  ): Promise<StickeringMask> => cubeLikeStickeringMask(cube3x3x3, stickering),\n  stickerings: () => cubeLikeStickeringList(\"3x3x3\"),\n  puzzleSpecificSimplifyOptions: puzzleSpecificSimplifyOptions333,\n} satisfies PuzzleLoader;\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const clock: PuzzleLoader = {\n  id: \"clock\",\n  fullName: \"Clock\",\n  inventedBy: [\"Christopher C. Wiggs\", \"Christopher J. Taylor\"],\n  inventionYear: 1988, // Patent application year: https://www.jaapsch.net/puzzles/patents/us4869506.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .clockJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .clockSVG;\n  }),\n};\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport {\n  type StickeringMask,\n  PuzzleStickering,\n  StickeringManager,\n  type PieceSet,\n  PieceStickering,\n} from \"./mask\";\n\nexport async function ftoStickering(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  const kpuzzle = await puzzleLoader.kpuzzle();\n  const puzzleStickering = new PuzzleStickering(kpuzzle);\n  const m = new StickeringManager(kpuzzle);\n\n  const experimentalFTO_FC = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.or(m.moves([\"F\", \"BL\", \"BR\"])))]);\n  const experimentalFTO_F2T = (): PieceSet =>\n    m.and([m.move(\"U\"), m.not(m.move(\"F\"))]);\n  const experimentalFTO_SC = (): PieceSet =>\n    m.or([\n      experimentalFTO_F2T(),\n      m.and([m.move(\"F\"), m.not(m.or(m.moves([\"U\", \"BL\", \"BR\"])))]),\n    ]);\n  const experimentalFTO_L2C = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"U\"), m.move(\"F\")]),\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n  const experimentalFTO_LBT = (): PieceSet =>\n    m.not(\n      m.or([\n        m.and([m.move(\"F\"), m.move(\"BL\")]),\n        m.and([m.move(\"F\"), m.move(\"BR\")]),\n        m.and([m.move(\"BL\"), m.move(\"BR\")]),\n      ]),\n    );\n\n  switch (stickering) {\n    case \"full\":\n      break;\n    case \"experimental-fto-fc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_FC()),\n        PieceStickering.Ignored,\n      );\n      break;\n    }\n    case \"experimental-fto-f2t\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_F2T()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_FC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-sc\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_SC()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_F2T(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l2c\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_L2C()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_SC(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-lbt\": {\n      puzzleStickering.set(\n        m.not(experimentalFTO_LBT()),\n        PieceStickering.Ignored,\n      );\n      puzzleStickering.set(experimentalFTO_L2C(), PieceStickering.Dim);\n      break;\n    }\n    case \"experimental-fto-l3t\": {\n      puzzleStickering.set(experimentalFTO_LBT(), PieceStickering.Dim);\n      break;\n    }\n    default:\n      console.warn(\n        `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n      );\n      puzzleStickering.set(m.and(m.moves([])), PieceStickering.Dim);\n  }\n  return puzzleStickering.toStickeringMask();\n}\n\nexport async function ftoStickerings(): Promise<ExperimentalStickering[]> {\n  return [\n    \"full\",\n    \"experimental-fto-fc\",\n    \"experimental-fto-f2t\",\n    \"experimental-fto-sc\",\n    \"experimental-fto-l2c\",\n    \"experimental-fto-lbt\",\n    \"experimental-fto-l3t\",\n  ];\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  ftoStickering,\n  ftoStickerings,\n} from \"../../stickerings/fto-stickerings\";\n\nclass FTOPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      pgID: \"FTO\",\n      id: \"fto\",\n      fullName: \"Face-Turning Octahedron\",\n      inventedBy: [\"Karl Rohrbach\", \"David Pitcher\"], // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n      inventionYear: 1983, // http://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1663\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return ftoStickering(this, stickering);\n  }\n  stickerings = ftoStickerings;\n  override svg = getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .ftoSVG;\n  });\n}\n\nexport const fto = new FTOPuzzleLoader();\n", "import type { ExperimentalStickering } from \"../../twisty\";\nimport type { PuzzleLoader } from \"../PuzzleLoader\";\nimport type { StickeringMask } from \"./mask\";\nimport {\n  cubeLikeStickeringList,\n  cubeLikeStickeringMask,\n} from \"./cube-like-stickerings\";\nimport { from } from \"../../vendor/mit/p-lazy/p-lazy\";\n\n// TODO: cache calculations?\nexport async function megaminxStickeringMask(\n  puzzleLoader: PuzzleLoader,\n  stickering: ExperimentalStickering,\n): Promise<StickeringMask> {\n  // TODO: optimize lookup instead of looking through a list\n  if ((await megaminxStickerings()).includes(stickering)) {\n    return cubeLikeStickeringMask(puzzleLoader, stickering);\n  }\n  console.warn(\n    `Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`,\n  );\n  return cubeLikeStickeringMask(puzzleLoader, \"full\");\n}\n\nconst megaminxStickeringListPromise: Promise<string[]> = from(() =>\n  cubeLikeStickeringList(\"megaminx\"),\n);\nexport function megaminxStickerings(): Promise<string[]> {\n  return megaminxStickeringListPromise;\n}\n", "import type { ExperimentalStickering } from \"../../../twisty\";\nimport { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { StickeringMask } from \"../../stickerings/mask\";\nimport {\n  megaminxStickeringMask,\n  megaminxStickerings,\n} from \"../../stickerings/megaminx-stickerings\";\n\nclass MegaminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"megaminx\",\n      fullName: \"Megaminx\",\n      // Too many simultaneous inventors to name.\n      inventionYear: 1981, // Earliest date from https://www.jaapsch.net/puzzles/megaminx.htm\n    });\n  }\n  stickeringMask(stickering: ExperimentalStickering): Promise<StickeringMask> {\n    return megaminxStickeringMask(this, stickering);\n  }\n  stickerings = megaminxStickerings;\n\n  llSVG = getCached(async () => {\n    return (await import(\"../dynamic/megaminx/puzzles-dynamic-megaminx\"))\n      .megaminxLLSVG;\n  });\n}\n\nexport const megaminx = new MegaminxPuzzleLoader();\n", "import { PGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\n\nclass PyraminxPuzzleLoader extends PGPuzzleLoader {\n  constructor() {\n    super({\n      id: \"pyraminx\",\n      fullName: \"Pyraminx\",\n      inventedBy: [\"Uwe Meffert\"],\n    });\n  }\n  override svg = getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .pyraminxSVG;\n  });\n}\n\nexport const pyraminx = new PyraminxPuzzleLoader();\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const square1: PuzzleLoader = {\n  id: \"square1\",\n  fullName: \"Square-1\",\n  inventedBy: [\"Karel Hr\u0161el\", \"Vojtech Kopsk\u00FD\"],\n  inventionYear: 1990, // Czech patent application year: http://spisy.upv.cz/Patents/FullDocuments/277/277266.pdf\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .sq1HyperOrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .sq1HyperOrbitSVG;\n  }),\n};\n", "import type { PuzzleLoader } from \"../..\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport {\n  asyncGetKPuzzleByDesc,\n  descAsyncGetPuzzleGeometry,\n} from \"../../customPGPuzzleLoader\";\n\nconst KILOMINX_PUZZLE_DESCRIPTION = \"d f 0.56\";\n\n// TODO: Make this consistent with Megaminx corners\nexport const kilominx: PuzzleLoader = {\n  id: \"kilominx\",\n  fullName: \"Kilominx\",\n  kpuzzle: getCached(() =>\n    asyncGetKPuzzleByDesc(KILOMINX_PUZZLE_DESCRIPTION, {\n      includeCenterOrbits: false,\n      includeEdgeOrbits: false,\n    }),\n  ),\n  pg: () =>\n    descAsyncGetPuzzleGeometry(KILOMINX_PUZZLE_DESCRIPTION, {\n      includeCenterOrbits: false,\n      includeEdgeOrbits: false,\n    }),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .kilominxSVG;\n  }),\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const rediCube: PuzzleLoader = {\n  id: \"redi_cube\",\n  fullName: \"Redi Cube\",\n  // Announced 2009-07-21: https://www.youtube.com/watch?v=cjfMzA1u3vM\n  // https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1520\n  inventedBy: [\"Oskar van Deventer\"],\n  inventionYear: 2009,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .rediCubeJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .rediCubeSVG;\n  },\n};\n", "import { CubePGPuzzleLoader } from \"../../async/async-pg3d\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nconst cube4x4x4: PuzzleLoader = new CubePGPuzzleLoader({\n  id: \"4x4x4\",\n  fullName: \"4\u00D74\u00D74 Cube\",\n});\n\ncube4x4x4.llSVG = getCached(async () => {\n  return (await import(\"../dynamic/4x4x4/puzzles-dynamic-4x4x4\"))\n    .cube4x4x4LLSVG;\n});\n\nexport { cube4x4x4 };\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const melindas2x2x2x2: PuzzleLoader = {\n  id: \"melindas2x2x2x2\",\n  fullName: \"Melinda's 2\u00D72\u00D72\u00D72\",\n  inventedBy: [\"Melinda Green\"],\n  // inventionYear: 20__, // TODO\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n          .melindas2x2x2x2OrbitJSON,\n      ),\n  ),\n  svg: getCached(async () => {\n    return (await import(\"../dynamic/side-events/puzzles-dynamic-side-events\"))\n      .melindas2x2x2x2OrbitSVG;\n  }),\n};\n", "import { KPuzzle } from \"../../../kpuzzle\";\nimport { getCached } from \"../../async/lazy-cached\";\nimport type { PuzzleLoader } from \"../../PuzzleLoader\";\n\nexport const loopover: PuzzleLoader = {\n  id: \"loopover\",\n  fullName: \"Loopover\",\n  inventedBy: [\"Cary Huang\"],\n  inventionYear: 2018,\n  kpuzzle: getCached(\n    async () =>\n      new KPuzzle(\n        (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n          .loopoverJSON,\n      ),\n  ),\n  svg: async () => {\n    return (await import(\"../dynamic/unofficial/puzzles-dynamic-unofficial\"))\n      .loopoverSVG;\n  },\n};\n", "export { eventInfo, wcaEventInfo, wcaEvents, twizzleEvents } from \"./events\";\nexport type { PuzzleLoader };\nexport { cube2x2x2, cube3x3x3 };\n\nimport { CubePGPuzzleLoader, PGPuzzleLoader } from \"./async/async-pg3d\";\nimport { cube2x2x2 } from \"./implementations/2x2x2\";\nimport { cube3x3x3 } from \"./implementations/3x3x3\";\nimport { clock } from \"./implementations/clock\";\nimport { fto } from \"./implementations/fto\";\nimport { megaminx } from \"./implementations/megaminx\";\nimport { pyraminx } from \"./implementations/pyraminx\";\nimport { square1 } from \"./implementations/square1\";\nimport { kilominx } from \"./implementations/kilominx\";\nimport type { PuzzleLoader } from \"./PuzzleLoader\";\nimport { rediCube } from \"./implementations/redi-cube\";\nimport { cube4x4x4 } from \"./implementations/4x4x4\";\nimport { melindas2x2x2x2 } from \"./implementations/melindas2x2x2x2\";\nimport { loopover } from \"./implementations/loopover\";\n\n/** @category All Puzzles */\nexport const puzzles: Record<string, PuzzleLoader> = {\n  /******** Start of WCA Puzzles *******/\n  \"3x3x3\": cube3x3x3,\n  \"2x2x2\": cube2x2x2,\n  \"4x4x4\": cube4x4x4,\n  \"5x5x5\": new CubePGPuzzleLoader({ id: \"5x5x5\", fullName: \"5\u00D75\u00D75 Cube\" }),\n  \"6x6x6\": new CubePGPuzzleLoader({ id: \"6x6x6\", fullName: \"6\u00D76\u00D76 Cube\" }),\n  \"7x7x7\": new CubePGPuzzleLoader({ id: \"7x7x7\", fullName: \"7\u00D77\u00D77 Cube\" }),\n  \"40x40x40\": new CubePGPuzzleLoader({\n    id: \"40x40x40\",\n    fullName: \"40\u00D740\u00D740 Cube\",\n  }),\n  // 3x3x3 Blindfolded\n  // 3x3x3 Fewest Moves\n  // 3x3x3 One-Handed\n  clock,\n  megaminx: megaminx,\n  pyraminx,\n  skewb: new PGPuzzleLoader({\n    id: \"skewb\",\n    fullName: \"Skewb\",\n    inventedBy: [\"Tony Durham\"], // https://www.jaapsch.net/puzzles/skewb.htm\n    // inventionYear: 1982, // 1982 is actually the year of Hofstadter's column.\n  }),\n  square1,\n  // 4x4x4 Blindfolded\n  // 5x5x5 Blindfolded\n  /******** End of WCA puzzles ********/\n  fto: fto,\n  gigaminx: new PGPuzzleLoader({\n    id: \"gigaminx\",\n    fullName: \"Gigaminx\",\n    inventedBy: [\"Tyler Fox\"],\n    inventionYear: 2006, // Earliest date from https://www.twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1475\n  }),\n  master_tetraminx: new PGPuzzleLoader({\n    pgID: \"master tetraminx\",\n    id: \"master_tetraminx\",\n    fullName: \"Master Tetraminx\",\n    inventedBy: [\"Katsuhiko Okamoto\"], // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n    inventionYear: 2002, // Using master pyraminx: https://twistypuzzles.com/cgi-bin/puzzle.cgi?pkey=1352\n  }),\n  kilominx,\n  redi_cube: rediCube,\n  melindas2x2x2x2,\n  loopover,\n};\n"],
  "mappings": "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",
  "names": ["transformationData", "_a", "pieceStickerings", "LL", "_a", "puzzleOrientationCacheRaw", "from", "_a", "moveSourceInfo", "directedAmount"]
}
