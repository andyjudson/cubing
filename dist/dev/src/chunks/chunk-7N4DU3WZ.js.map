{
  "version": 3,
  "sources": ["../../../../node_modules/cubing/src/cubing/notation/commonMetrics.ts", "../../../../node_modules/cubing/src/cubing/notation/cube3x3x3Metrics.ts", "../../../../node_modules/cubing/src/cubing/notation/CountMoves.ts", "../../../../node_modules/cubing/src/cubing/notation/CountAnimatedLeaves.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/inside-worker.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/addOrientationSuffix.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/3x3x3/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/convert.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/filter.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/3x3x3/legacy-sgs.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/2x2x2.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/tremble.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/sgs-side-events/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/twsearch.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/4x4x4/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/4x4x4.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/fto/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/fto.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/kilominx/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/kilominx.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/master_tetraminx/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/master_tetraminx.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/megaminx.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/pyraminx.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/sgs-unofficial/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/redi_cube.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/skewb.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/dynamic/sq1/index.ts", "../../../../node_modules/cubing/src/cubing/search/inside/solve/puzzles/sq1.ts", "../../../../node_modules/cubing/src/cubing/search/inside/api.ts"],
  "sourcesContent": ["export enum CommonMetric {\n  // OBTM (Outer Block Turn Metric)\n  OuterBlockTurnMetric = \"OBTM\",\n  // RBTM (Range Block Turn Metric)\n  RangeBlockTurnMetric = \"RBTM\",\n  // SSTM (Single Slice Turn Metric)\n  SingleSliceTurnMetric = \"SSTM\",\n  // OBQTM (Outer Block Quantum Turn Metric)\n  OuterBlockQuantumTurnMetric = \"OBQTM\",\n  // RBQTM (Range Block Quantum Turn Metric)\n  RangeBlockQuantumTurnMetric = \"RBQTM\",\n  // SSQTM (Single Slice Quantum Turn Metric)\n  SingleSliceQuantumTurnMetric = \"SSQTM\",\n  ExecutionTurnMetric = \"ETM\",\n}\n\nexport enum CommonMetricAlias {\n  // QTM (Quantum Turn Metric)\n  QuantumTurnMetric = \"OBQTM\",\n  // HTM (Hand Turn Metric)\n  HandTurnMetric = \"OBTM\",\n  // STM (Slice Turn Metric)\n  SliceTurnMetric = \"RBTM\",\n}\n", "// TODO: move this into the 3x3x3 puzzle loader.\n\nimport type { Move } from \"../alg\";\nimport { experimentalCube3x3x3KPuzzleDefinition } from \"../puzzles/cubing-private\";\nimport { CommonMetric } from \"./commonMetrics\";\n\nenum MoveType {\n  Rotation = \"Rotation\",\n  Outer = \"Outer\",\n  Inner = \"Inner\",\n}\n\nfunction uncachedMoveCount(moveQuantumString: string): MoveType {\n  if (\n    moveQuantumString.endsWith(\"v\") ||\n    [\"x\", \"y\", \"z\"].includes(moveQuantumString)\n  ) {\n    // Rv\n    return MoveType.Rotation;\n  }\n  if (\n    moveQuantumString.startsWith(\"2\") ||\n    [\"M\", \"E\", \"S\"].includes(moveQuantumString)\n  ) {\n    return MoveType.Inner;\n  }\n  return MoveType.Outer;\n}\n\nlet cache: Record<string, MoveType> | undefined;\nfunction getCache(): Record<string, MoveType> {\n  if (cache) {\n    return cache;\n  }\n  cache = {};\n  const moveQuantumStrings = [\n    ...Object.keys(experimentalCube3x3x3KPuzzleDefinition.moves),\n    ...Object.keys(experimentalCube3x3x3KPuzzleDefinition.derivedMoves!),\n  ];\n  for (const moveQuantumString of moveQuantumStrings) {\n    cache[moveQuantumString] = uncachedMoveCount(moveQuantumString);\n  }\n  return cache;\n}\n\n// Ancient wisdom: https://github.com/cubing/alg.js/blob/0599fad84d81b8d943ad3ea3e5dc191db8b6c157/alg.js#L638-L651\n/**\n * A move with an amount of 0 always has 0 cost. Else, the cost is\n *\n * constantFactor + amountFactor * Math.abs(move.amount)\n *\n */\nexport const costFactorsByMetric: Partial<\n  Record<\n    CommonMetric,\n    Record<\n      MoveType,\n      {\n        constantFactor: number;\n        amountFactor: number;\n      }\n    >\n  >\n> = {\n  // Note: these are hardcoded for 3x3x3. They will not automatically generalize to any other puzzles.\n  [CommonMetric.OuterBlockTurnMetric]: {\n    [MoveType.Rotation]: { constantFactor: 0, amountFactor: 0 },\n    [MoveType.Outer]: { constantFactor: 1, amountFactor: 0 },\n    [MoveType.Inner]: { constantFactor: 2, amountFactor: 0 },\n  },\n  [CommonMetric.RangeBlockTurnMetric]: {\n    [MoveType.Rotation]: { constantFactor: 0, amountFactor: 0 },\n    [MoveType.Outer]: { constantFactor: 1, amountFactor: 0 },\n    [MoveType.Inner]: { constantFactor: 1, amountFactor: 0 },\n  },\n  [CommonMetric.OuterBlockQuantumTurnMetric]: {\n    [MoveType.Rotation]: { constantFactor: 0, amountFactor: 0 },\n    [MoveType.Outer]: { constantFactor: 0, amountFactor: 1 },\n    [MoveType.Inner]: { constantFactor: 0, amountFactor: 2 },\n  },\n  [CommonMetric.RangeBlockQuantumTurnMetric]: {\n    [MoveType.Rotation]: { constantFactor: 0, amountFactor: 0 },\n    [MoveType.Outer]: { constantFactor: 0, amountFactor: 1 },\n    [MoveType.Inner]: { constantFactor: 0, amountFactor: 1 },\n  },\n  [CommonMetric.ExecutionTurnMetric]: {\n    [MoveType.Rotation]: { constantFactor: 1, amountFactor: 0 },\n    [MoveType.Outer]: { constantFactor: 1, amountFactor: 0 },\n    [MoveType.Inner]: { constantFactor: 1, amountFactor: 0 },\n  },\n};\n\nexport function countMove3x3x3(metric: CommonMetric, move: Move): number {\n  const costFactors = costFactorsByMetric[metric];\n  if (!costFactors) {\n    throw new Error(`Invalid metric for 3x3x3: ${metric}`);\n  }\n  const cache = getCache();\n  const moveQuantumString = move.quantum.toString();\n  if (!(moveQuantumString in cache)) {\n    throw new Error(`Invalid move for 3x3x3 ${metric}: ${moveQuantumString}`);\n  }\n  const costType = cache[moveQuantumString];\n  const { constantFactor, amountFactor } = costFactors[costType];\n  return constantFactor + amountFactor * Math.abs(move.amount);\n}\n", "// TODO: move this file somewhere permanent.\nimport {\n  Alg,\n  Commutator,\n  Conjugate,\n  functionFromTraversal,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalUp,\n} from \"../alg\";\nimport type { PuzzleLoader } from \"../puzzles\";\nimport { CommonMetric } from \"./commonMetrics\";\nimport { costFactorsByMetric, countMove3x3x3 } from \"./cube3x3x3Metrics\";\n\n/*\n *   For movecount, that understands puzzle rotations.  This code\n *   should be moved to the alg class, probably.\n */\nclass CountMoves extends TraversalUp<number> {\n  constructor(private metric: (move: Move) => number) {\n    super();\n  }\n\n  public traverseAlg(alg: Alg): number {\n    let r = 0;\n    for (const algNode of alg.childAlgNodes()) {\n      r += this.traverseAlgNode(algNode);\n    }\n    return r;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    const alg: Alg = grouping.alg;\n    return this.traverseAlg(alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(move: Move): number {\n    return this.metric(move);\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  // TODO: Remove spaces between repeated pauses (in traverseSequence)\n  public traversePause(_pause: Pause): number {\n    return 0;\n  }\n\n  public traverseNewline(_newLine: Newline): number {\n    return 0;\n  }\n\n  // TODO: Enforce being followed by a newline (or the end of the alg)?\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\nfunction isCharUppercase(c: string): boolean {\n  return \"A\" <= c && c <= \"Z\";\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction baseMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction etmMetric(_move: Move): number {\n  return 1;\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction rangeBlockTurnMetric(move: Move): number {\n  const fam = move.family;\n  if (\n    (isCharUppercase(fam[0]) && fam[fam.length - 1] === \"v\") ||\n    fam === \"x\" ||\n    fam === \"y\" ||\n    fam === \"z\" ||\n    fam === \"T\"\n  ) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\n// TODO: Implement a puzzle-specific way to calculate this.\nfunction quantumMetric(move: Move): number {\n  return Math.abs(move.amount) * rangeBlockTurnMetric(move);\n}\n\nexport const countMoves = functionFromTraversal(CountMoves, [baseMetric]);\nexport const countMovesETM = functionFromTraversal(CountMoves, [etmMetric]);\nexport const countRangeBlockQuantumMovesPG = functionFromTraversal(CountMoves, [\n  quantumMetric,\n]);\nexport const countRangeBlockMovesPG = functionFromTraversal(CountMoves, [\n  rangeBlockTurnMetric,\n]);\n\n/**\n * Only implemented so far:\n *\n * - 3x3x3: OBTM, RBTM, ETM\n */\nexport function countMetricMoves(\n  puzzleLoader: PuzzleLoader,\n  metric: CommonMetric,\n  alg: Alg,\n): number {\n  if (puzzleLoader.id === \"3x3x3\") {\n    if (metric in costFactorsByMetric) {\n      return functionFromTraversal(CountMoves, [\n        (move: Move) => countMove3x3x3(metric, move),\n      ])(alg);\n    }\n  } else {\n    switch (metric) {\n      case CommonMetric.ExecutionTurnMetric:\n        return countMovesETM(alg);\n      case CommonMetric.RangeBlockTurnMetric: {\n        if (puzzleLoader.pg) {\n          return countRangeBlockMovesPG(alg);\n        }\n        break;\n      }\n      case CommonMetric.RangeBlockQuantumTurnMetric: {\n        if (puzzleLoader.pg) {\n          return countRangeBlockQuantumMovesPG(alg);\n        }\n        break;\n      }\n    }\n  }\n  throw new Error(\"Unsupported puzzle or metric.\");\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\n\n// TODO: Include Pause, include amounts\nclass CountAnimatedLeaves extends TraversalUp<number, number> {\n  public traverseAlg(alg: Alg): number {\n    let total = 0;\n    for (const part of alg.childAlgNodes()) {\n      total += this.traverseAlgNode(part);\n    }\n    return total;\n  }\n\n  public traverseGrouping(grouping: Grouping): number {\n    return this.traverseAlg(grouping.alg) * Math.abs(grouping.amount);\n  }\n\n  public traverseMove(_move: Move): number {\n    return 1;\n  }\n\n  public traverseCommutator(commutator: Commutator): number {\n    return (\n      2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B))\n    );\n  }\n\n  public traverseConjugate(conjugate: Conjugate): number {\n    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);\n  }\n\n  public traversePause(_pause: Pause): number {\n    return 1;\n  }\n\n  public traverseNewline(_newline: Newline): number {\n    return 0;\n  }\n\n  public traverseLineComment(_comment: LineComment): number {\n    return 0;\n  }\n}\n\nexport const countAnimatedLeaves = functionFromTraversal(CountAnimatedLeaves);\n", "import { Alg } from \"../../../../../alg\";\nimport type { KPattern } from \"../../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../../puzzles\";\nimport { randomChoice } from \"random-uint-below\";\nimport { mustBeInsideWorker } from \"../../../inside-worker\";\nimport { addOrientationSuffix } from \"../../addOrientationSuffix\";\nimport { dynamic3x3x3min2phase } from \"../dynamic/3x3x3\";\nimport { toMin2PhasePattern } from \"./convert\";\nimport { passesFilter } from \"./filter\";\nimport { sgs3x3x3 } from \"./legacy-sgs\";\n\nexport async function random333Pattern(): Promise<KPattern> {\n  const kpuzzle = await puzzles[\"3x3x3\"].kpuzzle();\n  let pattern = kpuzzle.defaultPattern();\n  for (const piece of sgs3x3x3) {\n    pattern = pattern.applyAlg(Alg.fromString(randomChoice(piece)));\n  }\n  if (!passesFilter(kpuzzle, pattern)) {\n    return random333Pattern();\n  }\n  return pattern;\n}\n\nexport async function solve333(s: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  return Alg.fromString(\n    (await dynamic3x3x3min2phase).solvePattern(toMin2PhasePattern(s)),\n  );\n}\n\nexport async function random333Scramble(): Promise<Alg> {\n  return solve333(await random333Pattern());\n}\n\nexport async function initialize333(): Promise<void> {\n  (await dynamic3x3x3min2phase).initialize();\n}\n\nconst randomSuffixes = [\n  [null, \"Rw\", \"Rw2\", \"Rw'\", \"Fw\", \"Fw'\"],\n  [null, \"Dw\", \"Dw2\", \"Dw'\"],\n];\n\nexport async function random333OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random333Scramble(), randomSuffixes);\n}\n", "let isInsideWorker = false;\n\nexport function setIsInsideWorker(inside: boolean) {\n  isInsideWorker = inside;\n}\n\nexport function mustBeInsideWorker(): void {\n  if (!isInsideWorker) {\n    throw new Error(\n      \"Must be called from inside a worker, to avoid impact on page performance. Try importing from the top level of `cubing/solve`?\",\n    );\n  }\n}\n", "import { Alg, AlgBuilder, Move } from \"../../../alg\";\nimport { randomChoice } from \"random-uint-below\";\n\nexport function addOrientationSuffix(\n  alg: Alg,\n  suffixSpec: (null | string)[][],\n): Alg {\n  const algBuilder = new AlgBuilder();\n  algBuilder.experimentalPushAlg(alg);\n  for (const suffix of suffixSpec) {\n    const choice = randomChoice(suffix);\n    if (choice !== null) {\n      algBuilder.push(Move.fromString(choice));\n    }\n  }\n  return algBuilder.toAlg();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic3x3x3min2phase = from<\n  typeof import(\"./search-dynamic-solve-3x3x3\")\n>(() => import(\"./search-dynamic-solve-3x3x3\"));\n", "/*\n\nFace order:\n\n U\nLFRB\n D\n\n         | 0| 1| 2|\n         | 3| 4| 5|\n         | 6| 7| 8|\n| 9|10|11|18|19|20|27|28|29|36|37|38|\n|12|13|14|21|22|23|30|31|32|39|40|41|\n|15|16|17|24|25|26|33|34|35|42|43|44|\n         |45|46|47|\n         |48|49|50|\n         |51|52|53|\n*/\n\nimport type { KPattern } from \"../../../../../kpuzzle/KPattern\";\n\nconst reidEdgeOrder = \"UF UR UB UL DF DR DB DL FR FL BR BL\".split(\" \");\nconst reidCornerOrder = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\nconst centerOrder = \"U L F R B D\".split(\" \");\n\n// const stickers = [reidEdgeOrder, reidCornerOrder, centerOrder];\n\n// /*\n//                |1 20|0 20|1 10|\n//                |0 30|2 00|0 10|\n//                |1 30|0 00|1 00|\n// |1 22|0 31|1 31|1 32|0 01|1 01|1 02|0 11|1 11|1 12|0 21|1 21|\n// |0111|2 10|0 91|0 90|2 20|0 80|0 81|2 30|0101|0100|2 40|0110|\n// |1 61|0 71|1 52|1 51|0 41|1 42|1 41|0 51|1 72|1 71|0 61|1 62|\n//                |1 50|0 40|1 40|\n//                |0 70|2 50|0 50|\n//                |1 60|0 60|1 70|\n// */\n\nconst map: [number, number, number][] = [\n  [1, 2, 0],\n  [0, 2, 0],\n  [1, 1, 0],\n  [0, 3, 0],\n  [2, 0, 0],\n  [0, 1, 0],\n  [1, 3, 0],\n  [0, 0, 0],\n  [1, 0, 0],\n  [1, 0, 2],\n  [0, 1, 1],\n  [1, 1, 1],\n  [0, 8, 1],\n  [2, 3, 0],\n  [0, 10, 1],\n  [1, 4, 1],\n  [0, 5, 1],\n  [1, 7, 2],\n  [1, 3, 2],\n  [0, 0, 1],\n  [1, 0, 1],\n  [0, 9, 0],\n  [2, 2, 0],\n  [0, 8, 0],\n  [1, 5, 1],\n  [0, 4, 1],\n  [1, 4, 2],\n  [1, 5, 0],\n  [0, 4, 0],\n  [1, 4, 0],\n  [0, 7, 0],\n  [2, 5, 0],\n  [0, 5, 0],\n  [1, 6, 0],\n  [0, 6, 0],\n  [1, 7, 0],\n  [1, 2, 2],\n  [0, 3, 1],\n  [1, 3, 1],\n  [0, 11, 1],\n  [2, 1, 0],\n  [0, 9, 1],\n  [1, 6, 1],\n  [0, 7, 1],\n  [1, 5, 2],\n  [1, 1, 2],\n  [0, 2, 1],\n  [1, 2, 1],\n  [0, 10, 0],\n  [2, 4, 0],\n  [0, 11, 0],\n  [1, 7, 1],\n  [0, 6, 1],\n  [1, 6, 2],\n];\n\nfunction rotateLeft(s: string, i: number): string {\n  return s.slice(i) + s.slice(0, i);\n}\n\nfunction toReid333Struct(pattern: KPattern): string[][] {\n  const output: string[][] = [[], []];\n  for (let i = 0; i < 6; i++) {\n    if (pattern.patternData[\"CENTERS\"].pieces[i] !== i) {\n      throw new Error(\"non-oriented puzzles are not supported\");\n    }\n  }\n  for (let i = 0; i < 12; i++) {\n    output[0].push(\n      rotateLeft(\n        reidEdgeOrder[pattern.patternData[\"EDGES\"].pieces[i]],\n        pattern.patternData[\"EDGES\"].orientation[i],\n      ),\n    );\n  }\n  for (let i = 0; i < 8; i++) {\n    output[1].push(\n      rotateLeft(\n        reidCornerOrder[pattern.patternData[\"CORNERS\"].pieces[i]],\n        pattern.patternData[\"CORNERS\"].orientation[i],\n      ),\n    );\n  }\n  output.push(centerOrder);\n  return output;\n}\n\n// function toReid333String(state: Transformation): string {\n//   return toReid333Struct(state)\n//     .map((l) => l.join(\" \"))\n//     .join(\" \");\n// }\n\nexport function toMin2PhasePattern(pattern: KPattern): string {\n  const reid = toReid333Struct(pattern);\n  return map.map(([orbit, perm, ori]) => reid[orbit][perm][ori]).join(\"\");\n}\n", "import { Move } from \"../../../../../alg\";\nimport type { KPuzzle } from \"../../../../../kpuzzle\";\nimport { KPattern } from \"../../../../../kpuzzle\";\n\nexport function isEquivalentTranformationIgnoringCENTERS(\n  t1: KPattern,\n  t2: KPattern,\n): boolean {\n  const t1NoCenterOri = new KPattern(t1.kpuzzle, {\n    EDGES: t1.patternData.EDGES,\n    CORNERS: t1.patternData.CORNERS,\n    CENTERS: {\n      pieces: t1.patternData.CENTERS.pieces,\n      orientation: new Array(6).fill(0),\n    },\n  }).experimentalToTransformation()!;\n  const t2NoCenterOri = new KPattern(t2.kpuzzle, {\n    EDGES: t2.patternData.EDGES,\n    CORNERS: t2.patternData.CORNERS,\n    CENTERS: {\n      pieces: t2.patternData.CENTERS.pieces,\n      orientation: new Array(6).fill(0),\n    },\n  }).experimentalToTransformation()!;\n  return t1NoCenterOri.isIdentical(t2NoCenterOri);\n}\n\nexport function passesFilter(kpuzzle: KPuzzle, pattern: KPattern): boolean {\n  if (\n    isEquivalentTranformationIgnoringCENTERS(kpuzzle.defaultPattern(), pattern)\n  ) {\n    return false;\n  }\n\n  for (const face of \"ULFRBD\") {\n    for (let amount = 1; amount < 4; amount++) {\n      const transformation = kpuzzle\n        .moveToTransformation(new Move(face, amount))\n        .toKPattern();\n      if (isEquivalentTranformationIgnoringCENTERS(transformation, pattern)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n// TODO: implement tests\n// {\n//   const def = await puzzles[\"3x3x3\"].def();\n//   const kpuzzle = new KPuzzle(def);\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.applyAlg(parse(\"R\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.applyAlg(parse(\"D\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n//   kpuzzle.reset();\n//   kpuzzle.applyAlg(parse(\"(R' U' R U')5\"));\n//   console.log(passesFilter(def, kpuzzle.state));\n// }\n", "// TODO: Verify\nexport const sgs3x3x3: string[][] = [\n  [\n    \"R U'\",\n    \"R2 B\", //\n    \"D2 B2\",\n    \"D' L B'\", //\n    \"R' U'\",\n    \"B\", //\n    \"D B2\",\n    \"R' B\", //\n    \"L' U\",\n    \"L2 B'\", //\n    \"B2\",\n    \"D L B'\", //\n    \"L U\",\n    \"B'\", //\n    \"U'\",\n    \"R B\", //\n    \"D' B2\",\n    \"L B'\", //\n    \"U2\",\n    \"U L' B'\", //\n    \"\",\n    \"U' L' B'\", //\n    \"U\",\n    \"L' B'\",\n  ],\n  [\n    \"F2 L2\",\n    \"F' L'\",\n    \"R' F L2\", //\n    \"D' L2\",\n    \"F L2\",\n    \"F2 L'\", //\n    \"R' F' L'\",\n    \"R2 F L2\",\n    \"R2 F2 L'\", //\n    \"L2\",\n    \"F L'\",\n    \"D' L\", //\n    \"D2 L2\",\n    \"R2 F' L'\",\n    \"D L\", //\n    \"\",\n    \"L2 F L'\",\n    \"L F' L2\", //\n    \"L F L'\",\n    \"F' L2\",\n    \"L'\", //\n    \"D L2\",\n    \"D F L'\",\n    \"L\",\n  ],\n  [\n    \"R B U2 B'\",\n    \"R2 B U' B'\", //\n    \"F2 B U B'\",\n    \"F B2 L' B2\", //\n    \"B2 L B2\",\n    \"B U' B'\", //\n    \"R2 B U2 B'\",\n    \"R' B U' B'\", //\n    \"B2 L' B2\",\n    \"F B U B'\", //\n    \"B2 U' B2\",\n    \"B' L B\", //\n    \"L F' B D' B'\",\n    \"B' U' B2 D B'\", //\n    \"B U2 B'\",\n    \"R B U' B'\", //\n    \"B2 L2 B2\",\n    \"D' B' L B\", //\n    \"B U B'\",\n    \"F' B2 L' B2\", //\n    \"\",\n    \"B2 L' B' U' B'\",\n  ],\n  [\n    \"U F2 L2 U'\",\n    \"F' U L' U'\", //\n    \"F2 U L' U'\",\n    \"U F L2 U'\", //\n    \"U2 B2 U2\",\n    \"R' U' B U\", //\n    \"D2 U L U'\",\n    \"D U2 B' U2\", //\n    \"U L2 U'\",\n    \"F U L' U'\", //\n    \"D U L U'\",\n    \"U2 B' U2\", //\n    \"\",\n    \"U2 B' U' L' U'\", //\n    \"U2 L' U2\",\n    \"U' B U\", //\n    \"U L U'\",\n    \"D' U2 B' U2\", //\n    \"U L' U'\",\n    \"U2 B U2\",\n  ],\n  [\n    \"R' D' F2\",\n    \"F'\", //\n    \"F2\",\n    \"D R F'\", //\n    \"R D' F2\",\n    \"R2 F'\", //\n    \"D' F2\",\n    \"R F'\", //\n    \"F2 R' D' F2\",\n    \"F\", //\n    \"D2 F2\",\n    \"D' R F'\", //\n    \"R2 D' F2\",\n    \"R' F'\", //\n    \"D F2\",\n    \"D2 R F'\", //\n    \"\",\n    \"F R' D' F2\",\n  ],\n  [\n    \"R' D2 F' D F\",\n    \"R F2 R2 F2\",\n    \"R2 F' D2 F\", //\n    \"F' R2 D2 F\",\n    \"L D' L'\",\n    \"D F' D2 F\", //\n    \"F2 R2 F2\",\n    \"R F' D2 F\",\n    \"F' R2 D' F\", //\n    \"F' R' D2 F\",\n    \"F2 R' F2\",\n    \"L D L'\", //\n    \"F' R D' F\",\n    \"F2 R F2\",\n    \"F' D2 F\", //\n    \"\",\n    \"L D2 R D' L'\",\n    \"F' D2 F' R F2\", //\n    \"D2 R2 F2 R2 F2\",\n    \"D F' D' F\",\n    \"F' D F\",\n  ],\n  [\n    \"U F2 U'\",\n    \"R U F' U'\", //\n    \"D R U F2 U'\",\n    \"U F U'\", //\n    \"R2 U F2 U'\",\n    \"R' U F' U'\", //\n    \"R U F2 U'\",\n    \"R2 U F' U'\", //\n    \"\",\n    \"U L D L' F U'\", //\n    \"F2 D' R D F2\",\n    \"D2 U F U'\", //\n    \"R' U F2 U'\",\n    \"U F' U'\", //\n    \"F2 D2 R D2 F2\",\n    \"D U F U'\",\n  ],\n  [\n    \"R2\",\n    \"R' B' D B\", //\n    \"D R'\",\n    \"F' R2 F\", //\n    \"\",\n    \"R B' D B\", //\n    \"R'\",\n    \"B' D B\", //\n    \"D' R'\",\n    \"D2 F' R2 F\", //\n    \"R\",\n    \"R2 B' D B\", //\n    \"D2 R'\",\n    \"B' D' B\",\n  ],\n  [\n    \"R2 D' R2\",\n    \"F' R' F R\",\n    \"R D' R2 D R'\", //\n    \"D2 R2 D2 R2\",\n    \"R' D' F' R F\",\n    \"U F D F' U'\", //\n    \"\",\n    \"R2 D2 B R' B' R'\",\n    \"R' F D' F2 R F\", //\n    \"R2 D R2\",\n    \"F2 U F U' F\",\n    \"R' D F' R F\", //\n    \"D R2 D2 R2\",\n    \"U F D' F' U'\",\n    \"D R' D2 F' R F\", //\n    \"R2 D2 R2\",\n    \"U F D2 F' U'\",\n    \"R' D2 F' R F\",\n  ],\n  [\n    \"B R B'\",\n    \"F D F' B R2 B'\", //\n    \"D B R2 B'\",\n    \"D2 B R' B'\", //\n    \"B R2 B'\",\n    \"D B R' B'\", //\n    \"D' B R2 B'\",\n    \"B R' B'\", //\n    \"\",\n    \"B R2 B' D B R' B'\", //\n    \"D2 B R2 B'\",\n    \"D' B R' B'\",\n  ],\n  [\n    \"\",\n    \"R' D R F D2 F'\", //\n    \"R' D R\",\n    \"D F D' F'\", //\n    \"R F' R' F\",\n    \"F D' F'\", //\n    \"R' D' R\",\n    \"F D2 F'\", //\n    \"R' D2 R\",\n    \"F D F'\",\n  ],\n  [\n    \"\",\n    \"F2 D2 R F' R' D2 F' D2 F'\",\n    \"F2 D2 F' D' F D' F' D2 F'\", //\n    \"F2 D F2 D F2 D2 F2\",\n    \"D2 F L D2 L' D2 F'\",\n    \"D F D2 L D2 L' F'\", //\n    \"R' D B' D2 B D' R\",\n    \"R' D2 B' D2 B R\",\n    \"F D2 F' D F D F'\", //\n    \"F D' L D2 L' D F'\",\n    \"B D' F D B' D' F'\",\n    \"F D2 L D2 L' F'\", //\n    \"F D' L D L' D F'\",\n    \"F L D2 L' D2 F'\",\n    \"R' B' D2 B D2 R\",\n  ],\n  [\n    \"D'\",\n    \"F L D L' D' F'\", //\n    \"D2\",\n    \"L B D B' D' L'\", //\n    \"D\",\n    \"B' L' D' L D B\", //\n    \"\",\n    \"D F L D L' D' F'\",\n  ],\n  [\n    \"F' D2 F D F' D F\",\n    \"F' D' R' D R F\", //\n    \"F' R' D' R D F\",\n    \"B D R D' R' B'\", //\n    \"\",\n    \"D B' D' L' D L B\",\n  ],\n  [\n    \"D F D F' D F D2 F'\",\n    \"F' U2 B' R' B U2 F' L F' L' F'\", //\n    \"\",\n    \"D2 L D L2 F L F2 D F\",\n  ],\n  [\n    \"L B' L' F L B L' F'\",\n    \"F2 U F' D2 F U' F' D2 F'\",\n    \"D' F' D B D' F D B'\", //\n    \"F L2 F R2 F' L2 F R2 F2\",\n    \"D B D' F' D B' D' F\",\n    \"R F L F' R' F L' F'\", //\n    \"\",\n    \"D2 B L' U2 L B' D2 B L' U2 L B'\",\n    \"D2 F R' U2 R F' D2 F R' U2 R F'\", //\n    \"R F L' F' R' F L F'\",\n    \"D F D' B' D F' D' B\",\n    \"L2 F2 L' B2 L F2 L' B2 L'\",\n  ],\n  [\n    \"L B R' B' L' B R B'\",\n    \"R' B R F' R' B' R F\",\n    \"L D2 L U L' D2 L U' L2\", //\n    \"\",\n    \"D2 B' D2 F D' L2 F L2 F' D2 B D' F'\",\n    \"D2 F' R' F R2 B' D2 B D2 R' F D2 F'\", //\n    \"L B L' F L B' L' F'\",\n    \"F' D2 F' U' F D2 F' U F2\",\n    \"D' B' D F D' B D F'\",\n  ],\n  [\"\", \"D2 F' L U2 L' F D2 F' L U2 L' F\", \"D2 B' R U2 R' B D2 B' R U2 R' B\"],\n];\n", "import { Alg } from \"../../../../alg\";\nimport type { KPuzzle } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { cube2x2x2, puzzles } from \"../../../../puzzles\";\nimport { randomPermuteInPlace, randomUIntBelow } from \"random-uint-below\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\nimport { experimentalNormalize2x2x2Orientation } from \"../../../../puzzles/cubing-private\";\nimport { wasmTwsearch } from \"../twsearch\";\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const sgsCachedData: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedData222();\n      return new TrembleSolver(\n        await puzzles[\"2x2x2\"].kpuzzle(),\n        sgsCachedData,\n        \"URFLBD\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitialize222(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solve222HTMSubOptimal(\n  pattern: KPattern,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  return await wasmTwsearch((await cube2x2x2.kpuzzle()).definition, pattern, {\n    generatorMoves: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n    maxDepth,\n  });\n}\n\n// TODO: fix def consistency.\n// TODO: why is this ending up with the wrong rotation sometimes?\nexport async function solve222HTMOptimal(\n  pattern: KPattern,\n  maxDepth: number = 11,\n): Promise<Alg> {\n  mustBeInsideWorker();\n  const { normalizedPattern, normalizationAlg } =\n    experimentalNormalize2x2x2Orientation(pattern);\n  const orientedResult = await wasmTwsearch(\n    (await cube2x2x2.kpuzzle()).definition,\n    normalizedPattern,\n    {\n      generatorMoves: \"UFLR\".split(\"\"), // TODO: <U, F, R>\n      maxDepth,\n    },\n  );\n  return normalizationAlg.concat(orientedResult);\n}\n\n// TODO: fix def consistency.\nexport async function solve222ForScramble(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  return wasmTwsearch((await cube2x2x2.kpuzzle()).definition, pattern, {\n    generatorMoves: \"UFLR\".split(\"\"),\n    minDepth: 11,\n  });\n}\n\n// TODO: factor out and test.\nfunction mutatingRandomizeOrbit(\n  kpuzzle: KPuzzle,\n  orbitName: string,\n  pattern: KPattern,\n  options?: { orientationSum?: number },\n): void {\n  randomPermuteInPlace(pattern.patternData[orbitName].pieces);\n\n  const orbitDefinition = kpuzzle.lookupOrbitDefinition(orbitName);\n  const ori = pattern.patternData[orbitName].orientation;\n\n  let sum = 0;\n  for (let i = 0; i < orbitDefinition.numPieces; i++) {\n    const o = randomUIntBelow(orbitDefinition.numOrientations);\n    ori[i] = o;\n    sum += o;\n  }\n\n  // console.log(\"aaaa\", options && \"orientationSum\" in options);\n  if (options && \"orientationSum\" in options) {\n    // console.log(\"sfdsf\", options!.orientationSum),\n    ori[0] =\n      (((ori[0] + options.orientationSum! - sum) %\n        orbitDefinition.numOrientations) +\n        orbitDefinition.numOrientations) %\n      orbitDefinition.numOrientations;\n  }\n}\n\n// TODO: Use SGS?\nexport async function random222Pattern(): Promise<KPattern> {\n  const kpuzzle = await puzzles[\"2x2x2\"].kpuzzle();\n  const patternCopy: KPattern = new KPattern(\n    kpuzzle,\n    structuredClone(kpuzzle.defaultPattern().patternData),\n  ); // TODO\n  mutatingRandomizeOrbit(kpuzzle, \"CORNERS\", patternCopy, {\n    orientationSum: 0,\n  });\n  return patternCopy;\n}\n", "import { Alg, AlgBuilder, Move, QuantumMove } from \"../../../alg\";\nimport type { KPuzzle, KTransformation } from \"../../../kpuzzle\";\nimport type { KPattern } from \"../../../kpuzzle/KPattern\";\nimport { experimentalCountMoves } from \"../../../notation\";\nimport { randomChoice } from \"random-uint-below\";\nimport type { SGSCachedData } from \"./parseSGS\";\n\nconst DEFAULT_STAGE1_DEPTH_LIMIT = 2; // Moderately performant default.\n\nconst DOUBLECHECK_PLACED_PIECES = true;\nconst DEBUG = false;\n\n// TODO: Take moves instead of move names?\nfunction calculateMoves(\n  kpuzzle: KPuzzle,\n  moveNames: string[],\n): {\n  move: Move;\n  transformation: KTransformation;\n}[] {\n  const searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[] = [];\n  // const identity = identityTransformation(def); // TODO\n  // TODO: Make it easy to filter moves.\n  for (const moveName of moveNames) {\n    const rootMove = new Move(moveName);\n    if (rootMove.amount !== 1) {\n      throw new Error(\n        \"SGS cannot handle def moves with an amount other than 1 yet.\",\n      );\n    }\n    let transformation = kpuzzle.identityTransformation();\n    for (let i = 1; ; i++) {\n      transformation = transformation.applyMove(rootMove);\n      if (transformation.isIdentityTransformation()) {\n        break;\n      }\n      searchMoves.push({\n        move: rootMove.modified({ amount: i }),\n        transformation,\n      });\n    }\n  }\n  return searchMoves;\n}\n\n// function badRandomMoves(moves: string[], ksp: KSolvePuzzle): KSolvePuzzleState {\n//   // var sum = 0;\n//   var scramble = \"\";\n//   for (var i = 0; i < 1000; i++) {\n//     scramble = scramble + \" \" + moves[Math.floor(moves.length * Math.random())];\n//   }\n//   // var sol = \"\";\n//   const indexer = new TreeAlgIndexer(ksp, Alg.fromString(scramble));\n//   return indexer.transformAtIndex(indexer.numMoves()) as any; // TODO\n// }\n\nexport class TrembleSolver {\n  private searchMoves: {\n    move: Move;\n    transformation: KTransformation;\n  }[];\n\n  constructor(\n    private kpuzzle: KPuzzle,\n    private sgs: SGSCachedData,\n    trembleMoveNames?: string[],\n  ) {\n    this.searchMoves = calculateMoves(\n      this.kpuzzle,\n      trembleMoveNames ?? Object.keys(this.kpuzzle.definition.moves),\n    );\n  }\n\n  // public badRandomMoves(): KSolvePuzzleState {\n  //   return badRandomMoves(this.moves, this.ksp);\n  // }\n\n  public async solve(\n    pattern: KPattern,\n    stage1DepthLimit: number = DEFAULT_STAGE1_DEPTH_LIMIT,\n    quantumMoveOrder?: (quantumMove: QuantumMove) => number,\n  ): Promise<Alg> {\n    const transformation = pattern.experimentalToTransformation();\n    if (!transformation) {\n      throw new Error(\n        \"distinguishable pieces are not supported in tremble solver yt\",\n      );\n    }\n    let bestAlg: Alg | null = null;\n    let bestLen = 1000000;\n    const recur = (\n      recursiveTransformation: KTransformation, // TODO: Support KStatq1\n      togo: number,\n      sofar: Alg,\n    ) => {\n      // console.log(\"recur\");\n      if (togo === 0) {\n        const sgsAlg = this.sgsPhaseSolve(recursiveTransformation, bestLen);\n        if (!sgsAlg) {\n          return;\n        }\n        // console.log(\"sgs done!\", sofar.toString(), \"|\", sgsAlg.toString());\n        const newAlg = sofar.concat(sgsAlg).experimentalSimplify({\n          cancel: {\n            directional: \"any-direction\",\n            puzzleSpecificModWrap: \"canonical-centered\",\n          },\n          puzzleSpecificSimplifyOptions: { quantumMoveOrder },\n        });\n\n        const len = experimentalCountMoves(newAlg);\n        if (bestAlg === null || len < bestLen) {\n          if (DEBUG) {\n            console.log(`New best (${len} moves): ${newAlg.toString()}`);\n            console.log(`Tremble moves are: ${sofar.toString()}`);\n          }\n          bestAlg = newAlg;\n          bestLen = len;\n        }\n        return;\n      }\n      for (const searchMove of this.searchMoves) {\n        recur(\n          recursiveTransformation.applyTransformation(\n            searchMove.transformation,\n          ),\n          togo - 1,\n          sofar.concat([searchMove.move]),\n        );\n      }\n    };\n    for (let d = 0; d <= stage1DepthLimit; d++) {\n      recur(transformation, d, new Alg());\n    }\n    if (bestAlg === null) {\n      throw new Error(\"SGS search failed.\");\n    }\n    return bestAlg;\n  }\n\n  private sgsPhaseSolve(\n    initialTransformation: KTransformation, // TODO: Handle KPattern\n    bestLenSofar: number,\n  ): Alg | null {\n    // const pieceNames = \"UFR URB UBL ULF DRF DFL DLB DBR\".split(\" \");\n\n    // function loggo(s: string) {\n    //   // console.warn(s);\n    //   // document.body.appendChild(document.createElement(\"div\")).textContent = s;\n    // }\n\n    // console.log(\"sgsPhaseSolve\");\n    const algBuilder = new AlgBuilder();\n    let transformation = initialTransformation;\n    for (const step of this.sgs.ordering) {\n      const cubieSeq = step.pieceOrdering;\n      let key = \"\";\n      const inverseTransformation = transformation.invert();\n      for (let i = 0; i < cubieSeq.length; i++) {\n        const loc = cubieSeq[i];\n        const orbitName = loc.orbitName;\n        const idx = loc.permutationIdx;\n        key += ` ${inverseTransformation.transformationData[orbitName].permutation[idx]} ${inverseTransformation.transformationData[orbitName].orientationDelta[idx]}`;\n      }\n      // console.log(key, step.lookup);\n      const info = step.lookup[key];\n      if (!info) {\n        throw new Error(\"Missing algorithm in sgs or esgs?\");\n      }\n      algBuilder.experimentalPushAlg(info.alg);\n      if (algBuilder.experimentalNumAlgNodes() >= bestLenSofar) {\n        return null;\n      }\n      transformation = transformation.applyTransformation(info.transformation);\n      if (DOUBLECHECK_PLACED_PIECES) {\n        for (let i = 0; i < cubieSeq.length; i++) {\n          const location = cubieSeq[i];\n          const orbitName = location.orbitName;\n          const idx = location.permutationIdx;\n          if (\n            transformation.transformationData[orbitName].permutation[idx] !==\n              idx ||\n            transformation.transformationData[orbitName].orientationDelta[\n              idx\n            ] !== 0\n          ) {\n            throw new Error(\"bad SGS :-(\");\n          }\n        }\n      }\n    }\n    return algBuilder.toAlg();\n  }\n}\n\nexport function randomPatternFromSGS(\n  kpuzzle: KPuzzle,\n  sgs: SGSCachedData,\n): KPattern {\n  let transformation = kpuzzle.identityTransformation();\n  for (const step of sgs.ordering) {\n    const sgsAction = randomChoice(Object.values(step.lookup));\n    transformation = transformation.applyTransformation(\n      sgsAction.transformation,\n    );\n  }\n  return transformation.toKPattern();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicSideEvents = from<\n  typeof import(\"./search-dynamic-sgs-side-events\")\n>(() => import(\"./search-dynamic-sgs-side-events\"));\n", "import type { Alg } from \"../../../alg\";\nimport {\n  type KPuzzleDefinition,\n  type KTransformationData,\n  KPattern,\n} from \"../../../kpuzzle\";\nimport { from } from \"../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const twsearchPromise: Promise<\n  typeof import(\"../../../vendor/mpl/twsearch\")\n> = from(async () => import(\"../../../vendor/mpl/twsearch\"));\n\nexport interface TwsearchOptions {\n  // TODO: start prune depth?\n  generatorMoves?: string[];\n  targetPattern?: KTransformationData;\n  minDepth?: number;\n  maxDepth?: number;\n}\n\nexport async function wasmTwsearch(\n  def: KPuzzleDefinition,\n  pattern: KPattern,\n  options?: TwsearchOptions,\n): Promise<Alg> {\n  const { wasmTwsearch } = await twsearchPromise;\n  return wasmTwsearch(def, pattern, options);\n}\n\nexport async function wasmRandomScrambleForEvent(\n  eventID: string,\n): Promise<Alg> {\n  const { wasmRandomScrambleForEvent } = await twsearchPromise;\n  return wasmRandomScrambleForEvent(eventID);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamic4x4x4Solver = from<\n  typeof import(\"./search-dynamic-solve-4x4x4\")\n>(() => import(\"./search-dynamic-solve-4x4x4\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { addOrientationSuffix } from \"../addOrientationSuffix\";\nimport { dynamic4x4x4Solver } from \"./dynamic/4x4x4\";\n\nconst randomSuffixes = [\n  [null, \"x\", \"x2\", \"x'\", \"z\", \"z'\"],\n  [null, \"y\", \"y2\", \"y'\"],\n];\n\nexport async function initialize444(): Promise<void> {\n  return (await dynamic4x4x4Solver).initialize();\n}\n\nexport async function random444Scramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamic4x4x4Solver).random444Scramble();\n}\n\nexport async function random444OrientedScramble(): Promise<Alg> {\n  return addOrientationSuffix(await random444Scramble(), randomSuffixes);\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicFTOSolver = from<\n  typeof import(\"./search-dynamic-solve-fto\")\n>(() => import(\"./search-dynamic-solve-fto\"));\n", "import { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { from } from \"../../../../vendor/mit/p-lazy/p-lazy\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { dynamicFTOSolver } from \"./dynamic/fto\";\n\nconst dynamic = from<\n  typeof import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\")\n>(() => import(\"./dynamic/sgs-unofficial/search-dynamic-sgs-unofficial\"));\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (await dynamic).sgsDataFTO();\n      return new TrembleSolver(await puzzles[\"fto\"].kpuzzle(), json, [\n        \"U\",\n        \"R\",\n        \"F\",\n        \"L\",\n        \"D\",\n        \"B\",\n        \"BR\",\n        \"BL\",\n      ]);\n    })())\n  );\n}\n\nexport async function preInitializeFTO(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveFTO(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    pattern,\n    TREMBLE_DEPTH,\n    () => 3, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomFTOScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(await (await dynamicFTOSolver).randomFTOScrambleString());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicKilominxSolver = from<\n  typeof import(\"./search-dynamic-solve-kilominx\")\n>(() => import(\"./search-dynamic-solve-kilominx\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicKilominxSolver } from \"./dynamic/kilominx\";\n\nexport async function randomKilominxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await dynamicKilominxSolver).getRandomKilominxScramble();\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicMasterTetraminxSolver = from<\n  typeof import(\"./search-dynamic-solve-master_tetraminx\")\n>(() => import(\"./search-dynamic-solve-master_tetraminx\"));\n", "import { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { dynamicMasterTetraminxSolver } from \"./dynamic/master_tetraminx\";\n\nexport async function randomMasterTetraminxScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return new Alg(\n    await (\n      await dynamicMasterTetraminxSolver\n    ).randomMasterTetraminxScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPatternData } from \"../../../../kpuzzle\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 2;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).cachedSGSDataMegaminx();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n        json,\n        [\"U\", \"R\", \"F\", \"L\", \"BR\", \"BL\", \"FR\", \"FL\", \"DR\", \"DL\", \"B\", \"D\"],\n      );\n    })())\n  );\n}\n\nexport async function preInitializeMegaminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\n// TODO: centers\nexport async function solveMegaminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const patternDataWithoutMO: KPatternData = structuredClone(\n    pattern.patternData,\n  );\n  patternDataWithoutMO.CENTERS.orientation = new Array(12).fill(0);\n  const patternWithoutMO = new KPattern(\n    await (await searchDynamicSideEvents).cachedMegaminxKPuzzleWithoutMO(),\n    patternDataWithoutMO,\n  );\n  const alg = await trembleSolver.solve(\n    patternWithoutMO,\n    TREMBLE_DEPTH,\n    () => 5, // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n", "import type { Alg } from \"../../../../alg\";\nimport type { KPattern } from \"../../../../kpuzzle/KPattern\";\nimport { puzzles } from \"../../../../puzzles\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomPatternFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataPyraminx();\n      return new TrembleSolver(\n        await puzzles.pyraminx.kpuzzle(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializePyraminx(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nexport async function solvePyraminx(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(pattern, TREMBLE_DEPTH, () => 3); // TODO: Attach quantum move order lookup to puzzle.\n  return alg;\n}\n\nexport async function randomPyraminxPatternFixedOrientation(): Promise<KPattern> {\n  mustBeInsideWorker();\n  // Note: this sets all center orientations to 0.\n  return randomPatternFromSGS(\n    await puzzles.pyraminx.kpuzzle(),\n    await (await searchDynamicSideEvents).sgsDataPyraminxFixedOrientation(),\n  );\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const searchDynamicUnofficial = from<\n  typeof import(\"./search-dynamic-sgs-unofficial\")\n>(() => import(\"./search-dynamic-sgs-unofficial\"));\n", "import type { Alg } from \"../../../../alg\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport { searchDynamicUnofficial } from \"./dynamic/sgs-unofficial\";\n\nexport async function randomRediCubeScramble(): Promise<Alg> {\n  mustBeInsideWorker();\n  return (await searchDynamicUnofficial).getRandomRediCubeScramble();\n}\n", "import type { Alg, QuantumMove } from \"../../../../alg\";\nimport { KPattern } from \"../../../../kpuzzle\";\nimport { mustBeInsideWorker } from \"../../inside-worker\";\nimport type { SGSCachedData } from \"../parseSGS\";\nimport { randomPatternFromSGS, TrembleSolver } from \"../tremble\";\nimport { searchDynamicSideEvents } from \"./dynamic/sgs-side-events\";\n\nconst TREMBLE_DEPTH = 3;\n\nlet cachedTrembleSolver: Promise<TrembleSolver> | null = null;\nasync function getCachedTrembleSolver(): Promise<TrembleSolver> {\n  return (\n    cachedTrembleSolver ||\n    (cachedTrembleSolver = (async (): Promise<TrembleSolver> => {\n      const json: SGSCachedData = await (\n        await searchDynamicSideEvents\n      ).sgsDataSkewb();\n      return new TrembleSolver(\n        await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n        json,\n        \"RLUB\".split(\"\"),\n      );\n    })())\n  );\n}\n\nexport async function preInitializeSkewb(): Promise<void> {\n  await getCachedTrembleSolver();\n}\n\nasync function resetCenterOrientation(pattern: KPattern): Promise<KPattern> {\n  return new KPattern(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    {\n      CORNERS: pattern.patternData.CORNERS,\n      CENTERS: {\n        pieces: pattern.patternData.CENTERS.pieces,\n        orientation: new Array(6).fill(0),\n      },\n    },\n  );\n}\n\n// TODO: fix def consistency.\nexport async function solveSkewb(pattern: KPattern): Promise<Alg> {\n  mustBeInsideWorker();\n  const trembleSolver = await getCachedTrembleSolver();\n  const alg = await trembleSolver.solve(\n    await resetCenterOrientation(pattern),\n    TREMBLE_DEPTH,\n    (quantumMove: QuantumMove) => (quantumMove.family === \"y\" ? 4 : 3), // TODO: Attach quantum move order lookup to puzzle.\n  );\n  return alg;\n}\n\nexport async function randomSkewbFixedCornerPattern(): Promise<KPattern> {\n  // Note: this sets all center orientations to 0.\n  return randomPatternFromSGS(\n    await (await searchDynamicSideEvents).skewbKPuzzleWithoutMOCached(),\n    await (await searchDynamicSideEvents).sgsDataSkewbFixedCorner(),\n  );\n}\n\nexport async function randomSkewbFixedCornerScramble(): Promise<Alg> {\n  return solveSkewb(await randomSkewbFixedCornerPattern());\n}\n", "import { from } from \"../../../../../../vendor/mit/p-lazy/p-lazy\";\n\nexport const dynamicSq1Solver = from<\n  typeof import(\"./search-dynamic-solve-sq1\")\n>(() => import(\"./search-dynamic-solve-sq1\"));\n", "import { Alg } from \"../../../../alg\";\nimport { dynamicSq1Solver } from \"./dynamic/sq1\";\n\nexport async function getRandomSquare1Scramble(): Promise<Alg> {\n  return Alg.fromString(\n    await (await dynamicSq1Solver).getRandomSquare1ScrambleString(),\n  );\n}\n", "import type { Alg } from \"../../alg\";\nimport {\n  type KPuzzleDefinition,\n  KPattern,\n  type KPatternData,\n  KPuzzle,\n} from \"../../kpuzzle\";\nimport { puzzles } from \"../../puzzles\";\nimport { setIsInsideWorker } from \"./inside-worker\";\nimport { preInitialize222, solve222HTMSubOptimal } from \"./solve/puzzles/2x2x2\";\nimport {\n  initialize333,\n  random333OrientedScramble,\n  random333Scramble,\n  solve333,\n} from \"./solve/puzzles/3x3x3\";\nimport {\n  initialize444,\n  random444OrientedScramble,\n  random444Scramble,\n} from \"./solve/puzzles/4x4x4\";\nimport { randomFTOScramble } from \"./solve/puzzles/fto\";\nimport { randomKilominxScramble } from \"./solve/puzzles/kilominx\";\nimport { randomMasterTetraminxScramble } from \"./solve/puzzles/master_tetraminx\";\nimport { solveMegaminx } from \"./solve/puzzles/megaminx\";\nimport { solvePyraminx } from \"./solve/puzzles/pyraminx\";\nimport { randomRediCubeScramble } from \"./solve/puzzles/redi_cube\";\nimport {\n  randomSkewbFixedCornerScramble,\n  solveSkewb,\n} from \"./solve/puzzles/skewb\";\nimport { getRandomSquare1Scramble } from \"./solve/puzzles/sq1\";\nimport {\n  wasmRandomScrambleForEvent,\n  type TwsearchOptions,\n  wasmTwsearch,\n} from \"./solve/twsearch\";\n\nconst IDLE_PREFETCH_TIMEOUT_MS = 1000;\n\nsetIsInsideWorker(true);\n\nlet DEBUG_MEASURE_PERF = true;\nexport function setDebugMeasurePerf(newDebugMeasurePerf: boolean): void {\n  DEBUG_MEASURE_PERF = newDebugMeasurePerf;\n}\n\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\n\nasync function measurePerf<T>(\n  name: string,\n  f: () => T | Promise<T>,\n  options?: { isPrefetch?: boolean },\n): Promise<T> {\n  if (!DEBUG_MEASURE_PERF) {\n    return f();\n  }\n\n  const start = now();\n  const result = f();\n  if ((result as any)?.then) {\n    await result;\n  }\n  const end = now();\n  console.warn(\n    `${name}${options?.isPrefetch ? \" (prefetched)\" : \"\"}: ${Math.round(\n      end - start,\n    )}ms`,\n  );\n  return result;\n}\n\nconst prefetchPromises: Map<string, Promise<Alg>> = new Map();\n// This would just be a number, except `node` is extremely silly and returns an object instead.\n// https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\nlet queuedPrefetchTimeoutID: ReturnType<typeof setTimeout> | null = null;\n\nasync function randomScrambleForEvent(\n  eventID: string,\n  options?: { isPrefetch?: boolean },\n): Promise<Alg> {\n  switch (eventID) {\n    // case \"333\":\n    case \"222\":\n    // case \"444\":\n    case \"555\":\n    case \"666\":\n    case \"777\":\n    // case \"333bf\":\n    case \"333fm\":\n    // case \"333oh\":\n    // case \"clock\":\n    case \"minx\":\n    case \"pyram\":\n    // case \"skewb\":\n    // case \"sq1\":\n    // case \"444bf\":\n    case \"555bf\":\n      // case \"333mbf\":\n      // case \"fto\":\n      // case \"master_tetraminx\":\n      // case \"kilominx\":\n      // case \"redi_cube\":m\n      return measurePerf(\n        `wasmRandomScrambleForEvent(${JSON.stringify(eventID)})`,\n        () => wasmRandomScrambleForEvent(eventID),\n        {\n          isPrefetch: options?.isPrefetch,\n        },\n      );\n    case \"333\":\n    case \"333oh\":\n    case \"333ft\":\n      return measurePerf(\"random333Scramble\", random333Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"333bf\":\n    case \"333mbf\":\n      return measurePerf(\n        \"random333OrientedScramble\",\n        random333OrientedScramble,\n      );\n    case \"444\":\n      return measurePerf(\"random444Scramble\", random444Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"444bf\":\n      return measurePerf(\n        \"random444OrientedScramble\",\n        random444OrientedScramble,\n      );\n    case \"skewb\":\n      return measurePerf(\n        \"randomSkewbFixedCornerScramble\",\n        randomSkewbFixedCornerScramble,\n      );\n    case \"sq1\":\n      return measurePerf(\"getRandomSquare1Scramble\", getRandomSquare1Scramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"fto\":\n      return measurePerf(\"randomFTOScramble\", randomFTOScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"master_tetraminx\":\n      return measurePerf(\n        \"randomMasterTetraminxScramble\",\n        randomMasterTetraminxScramble,\n      );\n    case \"kilominx\":\n      return measurePerf(\"randomKilominxScramble\", randomKilominxScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    case \"redi_cube\":\n      return measurePerf(\"randomRediCubeScramble\", randomRediCubeScramble, {\n        isPrefetch: options?.isPrefetch,\n      });\n    default:\n      throw new Error(`unsupported event: ${eventID}`);\n  }\n}\n\nexport enum PrefetchLevel {\n  Auto = \"auto\",\n  None = \"none\",\n  Immediate = \"immediate\",\n}\n\nlet currentPrefetchLevel = PrefetchLevel.Auto;\n\nexport const insideAPI = {\n  initialize: async (eventID: string) => {\n    switch (eventID) {\n      case \"222\":\n        return measurePerf(\"preInitialize222\", preInitialize222);\n      case \"333\":\n      case \"333oh\":\n      case \"333ft\":\n        return measurePerf(\"initialize333\", initialize333);\n      case \"444\":\n        return measurePerf(\"initialize444\", initialize444);\n      default:\n        throw new Error(`unsupported event: ${eventID}`);\n    }\n  },\n\n  setScramblePrefetchLevel(prefetchLevel: `${PrefetchLevel}`) {\n    currentPrefetchLevel = prefetchLevel as PrefetchLevel;\n  },\n\n  randomScrambleForEvent: async (eventID: string): Promise<Alg> => {\n    let promise = prefetchPromises.get(eventID);\n    if (promise) {\n      prefetchPromises.delete(eventID);\n    } else {\n      promise = randomScrambleForEvent(eventID);\n    }\n    if (currentPrefetchLevel !== PrefetchLevel.None) {\n      promise.then(() => {\n        // `queuedPrefetch` could be 0, but:\n        // > Passing an invalid ID to clearTimeout() silently does nothing; no exception is thrown.\n        // https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout#notes\n        if (queuedPrefetchTimeoutID) {\n          clearTimeout(queuedPrefetchTimeoutID);\n        }\n        queuedPrefetchTimeoutID = setTimeout(\n          () => {\n            prefetchPromises.set(\n              eventID,\n              randomScrambleForEvent(eventID, {\n                isPrefetch: true,\n              }),\n            );\n          },\n          currentPrefetchLevel === PrefetchLevel.Immediate\n            ? 0\n            : IDLE_PREFETCH_TIMEOUT_MS,\n        );\n      });\n    }\n    return promise;\n  },\n\n  randomScrambleStringForEvent: async (eventID: string): Promise<string> => {\n    return (await insideAPI.randomScrambleForEvent(eventID)).toString();\n  },\n\n  solve333ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"3x3x3\"].kpuzzle(), patternData);\n    return (await solve333(pattern)).toString();\n  },\n\n  solve222ToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"2x2x2\"].kpuzzle(), patternData);\n    return (await solve222HTMSubOptimal(pattern)).toString();\n  },\n\n  solveSkewbToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(await puzzles[\"skewb\"].kpuzzle(), patternData);\n    return (await solveSkewb(pattern)).toString();\n  },\n\n  solvePyraminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"pyraminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solvePyraminx(pattern)).toString();\n  },\n\n  solveMegaminxToString: async (patternData: KPatternData): Promise<string> => {\n    const pattern = new KPattern(\n      await puzzles[\"megaminx\"].kpuzzle(),\n      patternData,\n    );\n    return (await solveMegaminx(pattern)).toString();\n  },\n\n  setDebugMeasurePerf: async (measure: boolean): Promise<void> => {\n    setDebugMeasurePerf(measure);\n  },\n\n  solveTwsearchToString: async (\n    def: KPuzzleDefinition,\n    patternData: KPatternData,\n    options?: TwsearchOptions,\n  ): Promise<string> => {\n    const kpuzzle = new KPuzzle(def);\n    const pattern = new KPattern(kpuzzle, patternData);\n    return (await wasmTwsearch(def, pattern, options)).toString();\n  },\n};\n\nexport type WorkerInsideAPI = typeof insideAPI;\n"],
  "mappings": "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E,MACE,yCAAyC,QAAQ,eAAe,GAAG,OAAO,GAC1E;AACA,WAAO;EACT;AAEA,aAAW,QAAQ,UAAU;AAC3B,aAAS,SAAS,GAAG,SAAS,GAAG,UAAU;AACzC,YAAM,iBAAiB,QACpB,qBAAqB,IAAI,KAAK,MAAM,MAAM,CAAC,EAC3C,WAAW;AACd,UAAI,yCAAyC,gBAAgB,OAAO,GAAG;AACrE,eAAO;MACT;IACF;EACF;AAEA,SAAO;AACT;AC7CO,IAAM,WAAuB;EAClC;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA;IACE;IACA;IACA;;IACA;IACA;IACA;;IACA;IACA;IACA;EACF;EACA,CAAC,IAAI,mCAAmC,iCAAiC;AAC3E;ANvRA,eAAsB,mBAAsC;AAC1D,QAAM,UAAU,MAAM,QAAQ,OAAO,EAAE,QAAQ;AAC/C,MAAI,UAAU,QAAQ,eAAe;AACrC,aAAW,SAAS,UAAU;AAC5B,cAAU,QAAQ,SAAS,IAAI,WAAWC,aAAa,KAAK,CAAC,CAAC;EAChE;AACA,MAAI,CAAC,aAAa,SAAS,OAAO,GAAG;AACnC,WAAO,iBAAiB;EAC1B;AACA,SAAO;AACT;AAEA,eAAsB,SAAS,GAA2B;AACxD,qBAAmB;AACnB,SAAO,IAAI;KACR,MAAM,uBAAuB,aAAa,mBAAmB,CAAC,CAAC;EAClE;AACF;AAEA,eAAsB,oBAAkC;AACtD,SAAO,SAAS,MAAM,iBAAiB,CAAC;AAC1C;AAEA,eAAsB,gBAA+B;AACnD,GAAC,MAAM,uBAAuB,WAAW;AAC3C;AAEA,IAAM,iBAAiB;EACrB,CAAC,MAAM,MAAM,OAAO,OAAO,MAAM,KAAK;EACtC,CAAC,MAAM,MAAM,OAAO,KAAK;AAC3B;AAEA,eAAsB,4BAA0C;AAC9D,SAAO,qBAAqB,MAAM,kBAAkB,GAAG,cAAc;AACvE;AQtCA,IAAM,6BAA6B;AAEnC,IAAM,4BAA4B;AAClC,IAAM,QAAQ;AAGd,SAAS,eACP,SACA,WAIE;AACF,QAAM,cAGA,CAAC;AAGP,aAAW,YAAY,WAAW;AAChC,UAAM,WAAW,IAAI,KAAK,QAAQ;AAClC,QAAI,SAAS,WAAW,GAAG;AACzB,YAAM,IAAI;QACR;MACF;IACF;AACA,QAAI,iBAAiB,QAAQ,uBAAuB;AACpD,aAAS,IAAI,KAAK,KAAK;AACrB,uBAAiB,eAAe,UAAU,QAAQ;AAClD,UAAI,eAAe,yBAAyB,GAAG;AAC7C;MACF;AACA,kBAAY,KAAK;QACf,MAAM,SAAS,SAAS,EAAE,QAAQ,EAAE,CAAC;QACrC;MACF,CAAC;IACH;EACF;AACA,SAAO;AACT;AAaO,IAAM,gBAAN,MAAoB;EAMzB,YACU,SACA,KACR,kBACA;AATM;AAME,SAAA,UAAA;AACA,SAAA,MAAA;AAGR,SAAK,cAAc;MACjB,KAAK;MACL,oBAAoB,OAAO,KAAK,KAAK,QAAQ,WAAW,KAAK;IAC/D;EACF;;;;EAMA,MAAa,MACX,SACA,mBAA2B,4BAC3B,kBACc;AACd,UAAM,iBAAiB,QAAQ,6BAA6B;AAC5D,QAAI,CAAC,gBAAgB;AACnB,YAAM,IAAI;QACR;MACF;IACF;AACA,QAAI,UAAsB;AAC1B,QAAI,UAAU;AACd,UAAM,QAAQ,CACZ,yBACA,MACA,UACG;AAEH,UAAI,SAAS,GAAG;AACd,cAAM,SAAS,KAAK,cAAc,yBAAyB,OAAO;AAClE,YAAI,CAAC,QAAQ;AACX;QACF;AAEA,cAAM,SAAS,MAAM,OAAO,MAAM,EAAE,qBAAqB;UACvD,QAAQ;YACN,aAAa;YACb,uBAAuB;UACzB;UACA,+BAA+B,EAAE,iBAAiB;QACpD,CAAC;AAED,cAAM,MAAM,WAAuB,MAAM;AACzC,YAAI,YAAY,QAAQ,MAAM,SAAS;AACrC,cAAI,OAAO;AACT,oBAAQ,IAAI,aAAa,GAAG,YAAY,OAAO,SAAS,CAAC,EAAE;AAC3D,oBAAQ,IAAI,sBAAsB,MAAM,SAAS,CAAC,EAAE;UACtD;AACA,oBAAU;AACV,oBAAU;QACZ;AACA;MACF;AACA,iBAAW,cAAc,KAAK,aAAa;AACzC;UACE,wBAAwB;YACtB,WAAW;UACb;UACA,OAAO;UACP,MAAM,OAAO,CAAC,WAAW,IAAI,CAAC;QAChC;MACF;IACF;AACA,aAAS,IAAI,GAAG,KAAK,kBAAkB,KAAK;AAC1C,YAAM,gBAAgB,GAAG,IAAI,IAAI,CAAC;IACpC;AACA,QAAI,YAAY,MAAM;AACpB,YAAM,IAAI,MAAM,oBAAoB;IACtC;AACA,WAAO;EACT;EAEQ,cACN,uBACA,cACY;AASZ,UAAM,aAAa,IAAI,WAAW;AAClC,QAAI,iBAAiB;AACrB,eAAW,QAAQ,KAAK,IAAI,UAAU;AACpC,YAAM,WAAW,KAAK;AACtB,UAAI,MAAM;AACV,YAAM,wBAAwB,eAAe,OAAO;AACpD,eAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,cAAM,MAAM,SAAS,CAAC;AACtB,cAAM,YAAY,IAAI;AACtB,cAAM,MAAM,IAAI;AAChB,eAAO,IAAI,sBAAsB,mBAAmB,SAAS,EAAE,YAAY,GAAG,CAAC,IAAI,sBAAsB,mBAAmB,SAAS,EAAE,iBAAiB,GAAG,CAAC;MAC9J;AAEA,YAAM,OAAO,KAAK,OAAO,GAAG;AAC5B,UAAI,CAAC,MAAM;AACT,cAAM,IAAI,MAAM,mCAAmC;MACrD;AACA,iBAAW,oBAAoB,KAAK,GAAG;AACvC,UAAI,WAAW,wBAAwB,KAAK,cAAc;AACxD,eAAO;MACT;AACA,uBAAiB,eAAe,oBAAoB,KAAK,cAAc;AACvE,UAAI,2BAA2B;AAC7B,iBAAS,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;AACxC,gBAAM,WAAW,SAAS,CAAC;AAC3B,gBAAM,YAAY,SAAS;AAC3B,gBAAM,MAAM,SAAS;AACrB,cACE,eAAe,mBAAmB,SAAS,EAAE,YAAY,GAAG,MAC1D,OACF,eAAe,mBAAmB,SAAS,EAAE,iBAC3C,GACF,MAAM,GACN;AACA,kBAAM,IAAI,MAAM,aAAa;UAC/B;QACF;MACF;IACF;AACA,WAAO,WAAW,MAAM;EAC1B;AACF;AAEO,SAAS,qBACd,SACA,KACU;AACV,MAAI,iBAAiB,QAAQ,uBAAuB;AACpD,aAAW,QAAQ,IAAI,UAAU;AAC/B,UAAM,YAAYA,aAAa,OAAO,OAAO,KAAK,MAAM,CAAC;AACzD,qBAAiB,eAAe;MAC9B,UAAU;IACZ;EACF;AACA,SAAO,eAAe,WAAW;AACnC;AChNO,IAAM,0BAA0B,KAErC,MAAM,OAAO,uDAAkC,CAAC;ACI3C,IAAM,kBAET,KAAK,YAAY,OAAO,iCAA8B,CAAC;AAU3D,eAAsB,aACpB,KACA,SACA,SACc;AACd,QAAM,EAAE,cAAAC,cAAa,IAAI,MAAM;AAC/B,SAAOA,cAAa,KAAK,SAAS,OAAO;AAC3C;AAEA,eAAsB,2BACpB,SACc;AACd,QAAM,EAAE,4BAAAC,4BAA2B,IAAI,MAAM;AAC7C,SAAOA,4BAA2B,OAAO;AAC3C;AHtBA,IAAI,sBAAqD;AACzD,eAAe,yBAAiD;AAC9D,SACE,wBACC,uBAAuB,YAAoC;AAC1D,UAAM,gBAA+B,OACnC,MAAM,yBACN,cAAc;AAChB,WAAO,IAAI;MACT,MAAM,QAAQ,OAAO,EAAE,QAAQ;MAC/B;MACA,SAAS,MAAM,EAAE;IACnB;EACF,GAAG;AAEP;AAEA,eAAsB,mBAAkC;AACtD,QAAM,uBAAuB;AAC/B;AAEA,eAAsB,sBACpB,SACA,WAAmB,IACL;AACd,qBAAmB;AACnB,SAAO,MAAM,cAAc,MAAM,UAAU,QAAQ,GAAG,YAAY,SAAS;IACzE,gBAAgB,OAAO,MAAM,EAAE;;IAC/B;EACF,CAAC;AACH;AIxCO,IAAM,qBAAqB,KAEhC,MAAM,OAAO,mDAA8B,CAAC;ACC9C,IAAMC,kBAAiB;EACrB,CAAC,MAAM,KAAK,MAAM,MAAM,KAAK,IAAI;EACjC,CAAC,MAAM,KAAK,MAAM,IAAI;AACxB;AAEA,eAAsB,gBAA+B;AACnD,UAAQ,MAAM,oBAAoB,WAAW;AAC/C;AAEA,eAAsB,oBAAkC;AACtD,qBAAmB;AACnB,UAAQ,MAAM,oBAAoB,kBAAkB;AACtD;AAEA,eAAsB,4BAA0C;AAC9D,SAAO,qBAAqB,MAAM,kBAAkB,GAAGA,eAAc;AACvE;ACnBO,IAAM,mBAAmB,KAE9B,MAAM,OAAO,iDAA4B,CAAC;ACK5C,IAAM,UAAU,KAEd,MAAM,OAAO,sDAAwD,CAAC;AAwCxE,eAAsB,oBAAkC;AACtD,qBAAmB;AACnB,SAAO,IAAI,IAAI,OAAO,MAAM,kBAAkB,wBAAwB,CAAC;AACzE;ACpDO,IAAM,wBAAwB,KAEnC,MAAM,OAAO,sDAAiC,CAAC;ACAjD,eAAsB,yBAAuC;AAC3D,qBAAmB;AACnB,UAAQ,MAAM,uBAAuB,0BAA0B;AACjE;ACLO,IAAM,+BAA+B,KAE1C,MAAM,OAAO,8DAAyC,CAAC;ACAzD,eAAsB,gCAA8C;AAClE,qBAAmB;AACnB,SAAO,IAAI;IACT,OACE,MAAM,8BACN,oCAAoC;EACxC;AACF;ACHA,IAAM,gBAAgB;AAEtB,IAAIC,uBAAqD;AACzD,eAAeC,0BAAiD;AAC9D,SACED,yBACCA,wBAAuB,YAAoC;AAC1D,UAAM,OAAsB,OAC1B,MAAM,yBACN,sBAAsB;AACxB,WAAO,IAAI;MACT,OAAO,MAAM,yBAAyB,+BAA+B;MACrE;MACA,CAAC,KAAK,KAAK,KAAK,KAAK,MAAM,MAAM,MAAM,MAAM,MAAM,MAAM,KAAK,GAAG;IACnE;EACF,GAAG;AAEP;AAOA,eAAsB,cAAc,SAAiC;AACnE,qBAAmB;AACnB,QAAM,gBAAgB,MAAMC,wBAAuB;AACnD,QAAM,uBAAqC;IACzC,QAAQ;EACV;AACA,uBAAqB,QAAQ,cAAc,IAAI,MAAM,EAAE,EAAE,KAAK,CAAC;AAC/D,QAAM,mBAAmB,IAAI;IAC3B,OAAO,MAAM,yBAAyB,+BAA+B;IACrE;EACF;AACA,QAAM,MAAM,MAAM,cAAc;IAC9B;IACA;IACA,MAAM;;EACR;AACA,SAAO;AACT;ACzCA,IAAMC,iBAAgB;AAEtB,IAAIF,uBAAqD;AACzD,eAAeC,0BAAiD;AAC9D,SACED,yBACCA,wBAAuB,YAAoC;AAC1D,UAAM,OAAsB,OAC1B,MAAM,yBACN,gBAAgB;AAClB,WAAO,IAAI;MACT,MAAM,QAAQ,SAAS,QAAQ;MAC/B;MACA,OAAO,MAAM,EAAE;IACjB;EACF,GAAG;AAEP;AAMA,eAAsB,cAAc,SAAiC;AACnE,qBAAmB;AACnB,QAAM,gBAAgB,MAAMC,wBAAuB;AACnD,QAAM,MAAM,MAAM,cAAc,MAAM,SAASC,gBAAe,MAAM,CAAC;AACrE,SAAO;AACT;AClCO,IAAM,0BAA0B,KAErC,MAAM,OAAO,sDAAiC,CAAC;ACAjD,eAAsB,yBAAuC;AAC3D,qBAAmB;AACnB,UAAQ,MAAM,yBAAyB,0BAA0B;AACnE;ACAA,IAAMA,iBAAgB;AAEtB,IAAIF,uBAAqD;AACzD,eAAeC,0BAAiD;AAC9D,SACED,yBACCA,wBAAuB,YAAoC;AAC1D,UAAM,OAAsB,OAC1B,MAAM,yBACN,aAAa;AACf,WAAO,IAAI;MACT,OAAO,MAAM,yBAAyB,4BAA4B;MAClE;MACA,OAAO,MAAM,EAAE;IACjB;EACF,GAAG;AAEP;AAMA,eAAe,uBAAuB,SAAsC;AAC1E,SAAO,IAAI;IACT,OAAO,MAAM,yBAAyB,4BAA4B;IAClE;MACE,SAAS,QAAQ,YAAY;MAC7B,SAAS;QACP,QAAQ,QAAQ,YAAY,QAAQ;QACpC,aAAa,IAAI,MAAM,CAAC,EAAE,KAAK,CAAC;MAClC;IACF;EACF;AACF;AAGA,eAAsB,WAAW,SAAiC;AAChE,qBAAmB;AACnB,QAAM,gBAAgB,MAAMC,wBAAuB;AACnD,QAAM,MAAM,MAAM,cAAc;IAC9B,MAAM,uBAAuB,OAAO;IACpCC;IACA,CAAC,gBAA8B,YAAY,WAAW,MAAM,IAAI;;EAClE;AACA,SAAO;AACT;AAEA,eAAsB,gCAAmD;AAEvE,SAAO;IACL,OAAO,MAAM,yBAAyB,4BAA4B;IAClE,OAAO,MAAM,yBAAyB,wBAAwB;EAChE;AACF;AAEA,eAAsB,iCAA+C;AACnE,SAAO,WAAW,MAAM,8BAA8B,CAAC;AACzD;AC/DO,IAAM,mBAAmB,KAE9B,MAAM,OAAO,iDAA4B,CAAC;ACD5C,eAAsB,2BAAyC;AAC7D,SAAO,IAAI;IACT,OAAO,MAAM,kBAAkB,+BAA+B;EAChE;AACF;AC+BA,IAAM,2BAA2B;AAEjC,kBAAkB,IAAI;AAEtB,IAAI,qBAAqB;AAClB,SAAS,oBAAoB,qBAAoC;AACtE,uBAAqB;AACvB;AAEA,SAAS,MAAM;AACb,UAAQ,OAAO,gBAAgB,cAAc,OAAO,aAAa,IAAI;AACvE;AAEA,eAAe,YACb,MACA,GACA,SACY;AACZ,MAAI,CAAC,oBAAoB;AACvB,WAAO,EAAE;EACX;AAEA,QAAM,QAAQ,IAAI;AAClB,QAAM,SAAS,EAAE;AACjB,MAAK,QAAgB,MAAM;AACzB,UAAM;EACR;AACA,QAAM,MAAM,IAAI;AAChB,UAAQ;IACN,GAAG,IAAI,GAAG,SAAS,aAAa,kBAAkB,EAAE,KAAK,KAAK;MAC5D,MAAM;IACR,CAAC;EACH;AACA,SAAO;AACT;AAEA,IAAM,mBAA8C,oBAAI,IAAI;AAG5D,IAAI,0BAAgE;AAEpE,eAAe,uBACb,SACA,SACc;AACd,UAAQ,SAAS;IAEf,KAAK;IAEL,KAAK;IACL,KAAK;IACL,KAAK;IAEL,KAAK;IAGL,KAAK;IACL,KAAK;IAIL,KAAK;AAMH,aAAO;QACL,8BAA8B,KAAK,UAAU,OAAO,CAAC;QACrD,MAAM,2BAA2B,OAAO;QACxC;UACE,YAAY,SAAS;QACvB;MACF;IACF,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO,YAAY,qBAAqB,mBAAmB;QACzD,YAAY,SAAS;MACvB,CAAC;IACH,KAAK;IACL,KAAK;AACH,aAAO;QACL;QACA;MACF;IACF,KAAK;AACH,aAAO,YAAY,qBAAqB,mBAAmB;QACzD,YAAY,SAAS;MACvB,CAAC;IACH,KAAK;AACH,aAAO;QACL;QACA;MACF;IACF,KAAK;AACH,aAAO;QACL;QACA;MACF;IACF,KAAK;AACH,aAAO,YAAY,4BAA4B,0BAA0B;QACvE,YAAY,SAAS;MACvB,CAAC;IACH,KAAK;AACH,aAAO,YAAY,qBAAqB,mBAAmB;QACzD,YAAY,SAAS;MACvB,CAAC;IACH,KAAK;AACH,aAAO;QACL;QACA;MACF;IACF,KAAK;AACH,aAAO,YAAY,0BAA0B,wBAAwB;QACnE,YAAY,SAAS;MACvB,CAAC;IACH,KAAK;AACH,aAAO,YAAY,0BAA0B,wBAAwB;QACnE,YAAY,SAAS;MACvB,CAAC;IACH;AACE,YAAM,IAAI,MAAM,sBAAsB,OAAO,EAAE;EACnD;AACF;AAQA,IAAI,uBAAuB;AAEpB,IAAM,YAAY;EACvB,YAAY,OAAO,YAAoB;AACrC,YAAQ,SAAS;MACf,KAAK;AACH,eAAO,YAAY,oBAAoB,gBAAgB;MACzD,KAAK;MACL,KAAK;MACL,KAAK;AACH,eAAO,YAAY,iBAAiB,aAAa;MACnD,KAAK;AACH,eAAO,YAAY,iBAAiB,aAAa;MACnD;AACE,cAAM,IAAI,MAAM,sBAAsB,OAAO,EAAE;IACnD;EACF;EAEA,yBAAyB,eAAmC;AAC1D,2BAAuB;EACzB;EAEA,wBAAwB,OAAO,YAAkC;AAC/D,QAAI,UAAU,iBAAiB,IAAI,OAAO;AAC1C,QAAI,SAAS;AACX,uBAAiB,OAAO,OAAO;IACjC,OAAO;AACL,gBAAU,uBAAuB,OAAO;IAC1C;AACA,QAAI,yBAAyB,QAAoB;AAC/C,cAAQ,KAAK,MAAM;AAIjB,YAAI,yBAAyB;AAC3B,uBAAa,uBAAuB;QACtC;AACA,kCAA0B;UACxB,MAAM;AACJ,6BAAiB;cACf;cACA,uBAAuB,SAAS;gBAC9B,YAAY;cACd,CAAC;YACH;UACF;UACA,yBAAyB,cACrB,IACA;QACN;MACF,CAAC;IACH;AACA,WAAO;EACT;EAEA,8BAA8B,OAAO,YAAqC;AACxE,YAAQ,MAAM,UAAU,uBAAuB,OAAO,GAAG,SAAS;EACpE;EAEA,kBAAkB,OAAO,gBAA+C;AACtE,UAAM,UAAU,IAAI,SAAS,MAAM,QAAQ,OAAO,EAAE,QAAQ,GAAG,WAAW;AAC1E,YAAQ,MAAM,SAAS,OAAO,GAAG,SAAS;EAC5C;EAEA,kBAAkB,OAAO,gBAA+C;AACtE,UAAM,UAAU,IAAI,SAAS,MAAM,QAAQ,OAAO,EAAE,QAAQ,GAAG,WAAW;AAC1E,YAAQ,MAAM,sBAAsB,OAAO,GAAG,SAAS;EACzD;EAEA,oBAAoB,OAAO,gBAA+C;AACxE,UAAM,UAAU,IAAI,SAAS,MAAM,QAAQ,OAAO,EAAE,QAAQ,GAAG,WAAW;AAC1E,YAAQ,MAAM,WAAW,OAAO,GAAG,SAAS;EAC9C;EAEA,uBAAuB,OAAO,gBAA+C;AAC3E,UAAM,UAAU,IAAI;MAClB,MAAM,QAAQ,UAAU,EAAE,QAAQ;MAClC;IACF;AACA,YAAQ,MAAM,cAAc,OAAO,GAAG,SAAS;EACjD;EAEA,uBAAuB,OAAO,gBAA+C;AAC3E,UAAM,UAAU,IAAI;MAClB,MAAM,QAAQ,UAAU,EAAE,QAAQ;MAClC;IACF;AACA,YAAQ,MAAM,cAAc,OAAO,GAAG,SAAS;EACjD;EAEA,qBAAqB,OAAO,YAAoC;AAC9D,wBAAoB,OAAO;EAC7B;EAEA,uBAAuB,OACrB,KACA,aACA,YACoB;AACpB,UAAM,UAAU,IAAI,QAAQ,GAAG;AAC/B,UAAM,UAAU,IAAI,SAAS,SAAS,WAAW;AACjD,YAAQ,MAAM,aAAa,KAAK,SAAS,OAAO,GAAG,SAAS;EAC9D;AACF;",
  "names": ["cache", "randomChoice", "wasmTwsearch", "wasmRandomScrambleForEvent", "randomSuffixes", "cachedTrembleSolver", "getCachedTrembleSolver", "TREMBLE_DEPTH"]
}
