{
  "version": 3,
  "sources": ["../../src/bin/puzzle-geometry-bin.ts"],
  "sourcesContent": ["// To run this file directly:\n// bun run src/bin/puzzle-geometry-bin.ts -- <program args>\n\nimport {\n  type ExperimentalPuzzleBaseShape,\n  type ExperimentalPuzzleCutType,\n  getPG3DNamedPuzzles,\n  parsePuzzleDescription,\n  PuzzleGeometry,\n  type ExperimentalPuzzleGeometryOptions,\n} from \"cubing/puzzle-geometry\";\nimport type { PuzzleDescriptionString } from \"cubing/puzzle-geometry/PGPuzzles\";\nimport type {\n  PuzzleCutDescription,\n  PuzzleDescription,\n} from \"cubing/puzzle-geometry/PuzzleGeometry\";\n\nexport function asstructured(v: any): any {\n  if (typeof v === \"string\") {\n    return JSON.parse(v);\n  }\n  return v;\n}\nexport function asboolean(v: any): boolean {\n  if (typeof v === \"string\") {\n    if (v === \"false\") {\n      return false;\n    }\n    return true;\n  } else {\n    return v ? true : false;\n  }\n}\nexport function parsePGOptionList(\n  optionlist?: any[],\n): ExperimentalPuzzleGeometryOptions {\n  const options: ExperimentalPuzzleGeometryOptions = {};\n  if (optionlist !== undefined) {\n    if (optionlist.length % 2 !== 0) {\n      throw new Error(\"Odd length in option list?\");\n    }\n    for (let i = 0; i < optionlist.length; i += 2) {\n      if (optionlist[i] === \"verbose\") {\n        options.verbosity = (options.verbosity ?? 0) + 1;\n      } else if (optionlist[i] === \"quiet\") {\n        options.verbosity = 0;\n      } else if (optionlist[i] === \"allmoves\") {\n        options.allMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"outerblockmoves\") {\n        options.outerBlockMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"vertexmoves\") {\n        options.vertexMoves = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"rotations\") {\n        options.addRotations = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"cornersets\") {\n        options.includeCornerOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"centersets\") {\n        options.includeCenterOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"edgesets\") {\n        options.includeEdgeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"omit\") {\n        options.excludeOrbits = optionlist[i + 1];\n      } else if (optionlist[i] === \"graycorners\") {\n        options.grayCorners = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"graycenters\") {\n        options.grayCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"grayedges\") {\n        options.grayEdges = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"movelist\") {\n        options.moveList = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"killorientation\") {\n        options.fixedOrientation = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"optimize\") {\n        options.optimizeOrbits = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"scramble\") {\n        options.scrambleAmount = optionlist[i + 1];\n      } else if (optionlist[i] === \"fix\") {\n        options.fixedPieceType = optionlist[i + 1];\n      } else if (optionlist[i] === \"orientcenters\") {\n        options.orientCenters = asboolean(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientation\") {\n        options.puzzleOrientation = asstructured(optionlist[i + 1]);\n      } else if (optionlist[i] === \"puzzleorientations\") {\n        options.puzzleOrientations = asstructured(optionlist[i + 1]);\n      } else {\n        throw new Error(\n          `Bad option while processing option list ${optionlist[i]}`,\n        );\n      }\n    }\n  }\n  return options;\n}\n\nlet dosvg = false;\nlet doss = false;\nlet doksolve = false;\nlet dogap = false;\nlet domathematica = false;\nlet docanon = false;\nlet do3d = false;\nif (globalThis.process && process.argv && process.argv.length <= 2) {\n  console.log(\n    `Usage:  puzzle-geometry [options] [puzzle]\n\nOptions:\n--ksolve: write ksolve (tws) file\n--svg: write SVG (default is flat; --3d makes it 3D)\n--gap: write gap\n--mathematica: write mathematica\n--ss: execute Schrier-Sims calculation\n--3d: use 3D format for SVG file\n--canon: write canonical string analysis\n--rotations: include full-puzzle rotations as moves\n--allmoves: includes all moves (i.e., slice moves for 3x3x3)\n--outerblockmoves: use outer block moves rather than slice moves\n--vertexmoves: for tetrahedral puzzles, prefer vertex moves to face moves\n--nocorners: ignore all corners\n--noedges: ignore all edges\n--nocenters: ignore all centers\n--noorientation: ignore orientations\n--orientcenters: give centers an orientation\n--puzzleorientation:  for 3D formats, give puzzle orientation\n--moves movenames: restrict moves to this list (e.g, U2,F,r)\n--optimize: optimize tws/ksolve/gap output\n--scramble: scramble solved position\n--fixcorner: choose moves to keep one corner fixed\n--fixedge: choose moves to keep one edge fixed\n--fixcenter: choose moves to keep one center fixed\n--verbose (-v): make verbose\n\nThe puzzle can be given as a geometric description or by name.\nThe geometric description starts with c (cube), t (tetrahedron),\nd (dodecahedron), i (icosahedron), or o (octahedron), then a\nspace, then a series of cuts.  Each cut begins with f (for a\ncut parallel to faces), v (for a cut perpendicular to a ray\nfrom the center through a corner), or e (for a cut perpendicular\nto a ray from the center through an edge) followed by a decimal\nnumber giving a distance, where 1 is the distance between the\ncenter of the puzzle and the center of a face.\n\nThe puzzle names recognized are 2x2x2 through 13x13x13, 20x20x20,\nmaster skewb, professor skewb, compy cube, helicopter, dino,\nlittle chop, pyramorphix, mastermorphix, pyraminx, Jing pyraminx,\nmaster paramorphix, megaminx, gigaminx, pentultimate, starminx,\nstarminx 2, pyraminx crystal, chopasaurus, big chop, skewb diamond,\nFTO, Christopher's jewel, octastar, Trajber's octahedron, radio chop,\nicosamate, icosahedron 2, icosahedron 3, icosahedron static faces,\nicosahedron moving faces, and Eitan's star.\n\nExamples:\n   puzzlegeometry --ss 2x2x2\n   puzzlegeometry --ss --fixcorner 2x2x2\n   puzzlegeometry --ss --moves U,F2,r 4x4x4\n   puzzlegeometry --ksolve --optimize --moves U,F,R megaminx\n   puzzlegeometry --gap --noedges megaminx\n`,\n  );\n}\nif (globalThis.process && process.argv && process.argv.length >= 3) {\n  let desc: PuzzleDescriptionString | undefined;\n  const puzzleList = getPG3DNamedPuzzles();\n  let argp = 2;\n  const optionlist = [];\n  let showargs = true;\n  let pascalcomment = false;\n  while (argp < process.argv.length && process.argv[argp][0] === \"-\") {\n    const option = process.argv[argp++];\n    if (option === \"--verbose\" || option === \"-v\") {\n      optionlist.push(\"verbose\", true);\n    } else if (option === \"--quiet\" || option === \"-q\") {\n      optionlist.push(\"quiet\", true);\n      showargs = false;\n    } else if (option === \"--ksolve\") {\n      doksolve = true;\n    } else if (option === \"--svg\") {\n      showargs = false;\n      optionlist.push(\"quiet\", true);\n      dosvg = true;\n    } else if (option === \"--gap\") {\n      dogap = true;\n    } else if (option === \"--mathematica\") {\n      domathematica = true;\n      pascalcomment = true;\n    } else if (option === \"--ss\") {\n      doss = true;\n    } else if (option === \"--3d\") {\n      do3d = true;\n    } else if (option === \"--canon\") {\n      docanon = true;\n    } else if (option === \"--rotations\") {\n      optionlist.push(\"rotations\", true);\n    } else if (option === \"--allmoves\") {\n      optionlist.push(\"allmoves\", true);\n    } else if (option === \"--outerblockmoves\") {\n      optionlist.push(\"outerblockmoves\", true);\n    } else if (option === \"--vertexmoves\") {\n      optionlist.push(\"vertexmoves\", true);\n    } else if (option === \"--nocorners\") {\n      optionlist.push(\"cornersets\", false);\n    } else if (option === \"--noedges\") {\n      optionlist.push(\"edgesets\", false);\n    } else if (option === \"--noorientation\") {\n      optionlist.push(\"killorientation\", true);\n    } else if (option === \"--nocenters\") {\n      optionlist.push(\"centersets\", false);\n    } else if (option === \"--omit\") {\n      optionlist.push(\"omit\", process.argv[argp].split(\",\"));\n      argp++;\n    } else if (option === \"--moves\") {\n      optionlist.push(\"movelist\", process.argv[argp].split(\",\"));\n      argp++;\n    } else if (option === \"--optimize\") {\n      optionlist.push(\"optimize\", true);\n    } else if (option === \"--scramble\") {\n      optionlist.push(\"scramble\", 100);\n    } else if (option === \"--fixcorner\") {\n      optionlist.push(\"fix\", \"v\");\n    } else if (option === \"--fixedge\") {\n      optionlist.push(\"fix\", \"e\");\n    } else if (option === \"--fixcenter\") {\n      optionlist.push(\"fix\", \"f\");\n    } else if (option === \"--orientcenters\") {\n      optionlist.push(\"orientcenters\", true);\n    } else if (option === \"--puzzleorientation\") {\n      optionlist.push(\"puzzleorientation\", process.argv[argp]);\n      argp++;\n    } else {\n      throw new Error(`Bad option: ${option}`);\n    }\n  }\n  for (const [name, curDesc] of Object.entries(puzzleList)) {\n    if (name === process.argv[argp]) {\n      desc = curDesc;\n      break;\n    }\n  }\n  let puzzleDescription: PuzzleDescription;\n  if (showargs) {\n    if (pascalcomment) {\n      console.log(`(* ${process.argv.join(\" \")} *)`);\n    } else {\n      console.log(`# ${process.argv.join(\" \")}`);\n    }\n  }\n  if (desc !== undefined) {\n    const parsed = parsePuzzleDescription(desc);\n    if (parsed === null) {\n      throw new Error(\"Could not parse puzzle description!\");\n    }\n    puzzleDescription = parsed;\n    argp++;\n  } else {\n    const cuts: PuzzleCutDescription[] = [];\n    const cutarg = argp++;\n    while (argp + 1 < process.argv.length && process.argv[argp].length === 1) {\n      // TODO: validate cut type\n      cuts.push({\n        cutType: process.argv[argp] as ExperimentalPuzzleCutType,\n        distance: parseFloat(process.argv[argp + 1]),\n      });\n      argp += 2;\n    }\n    // TODO: validate shape\n    puzzleDescription = {\n      shape: process.argv[cutarg] as ExperimentalPuzzleBaseShape,\n      cuts,\n    };\n  }\n  const options = parsePGOptionList(optionlist);\n  const pg = new PuzzleGeometry(puzzleDescription, options);\n  pg.allstickers();\n  pg.genperms();\n  if (argp < process.argv.length) {\n    throw new Error(\"Unprocessed content at end of command line\");\n  }\n  if (dogap) {\n    console.log(pg.writegap());\n  } else if (domathematica) {\n    console.log(pg.writemathematica());\n  } else if (doksolve) {\n    console.log(pg.writeksolve()); // TODO: Update arguments\n  } else if (dosvg) {\n    console.log(pg.generatesvg(undefined, undefined, undefined, do3d));\n  } else if (do3d) {\n    console.log(JSON.stringify(pg.get3d()));\n  } else if (doss) {\n    pg.writeSchreierSims(console.log);\n  } else if (docanon) {\n    pg.showcanon((_) => console.log(_));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
