{
  "version": 3,
  "sources": ["../../../../src/cubing/protocol/binary/orbit-indexing.ts", "../../../../src/cubing/protocol/binary/binary3x3x3.ts", "../../../../src/cubing/protocol/binary/hex.ts"],
  "sourcesContent": ["export function identityPermutation(numElems: number): number[] {\n  const arr = new Array<number>(numElems);\n  for (let i = 0; i < numElems; i++) {\n    arr[i] = i;\n  }\n  return arr;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function orientationsToMask(\n  radix: number,\n  orientations: number[],\n): number {\n  let val = 0;\n  for (const orientation of orientations) {\n    val *= radix;\n    val += orientation;\n  }\n  return val;\n}\n\n// Inclusive start, exclusive end (similar to `Array.prototype.slice`)\nexport function maskToOrientations(\n  radix: number,\n  numElems: number,\n  mask: number,\n): number[] {\n  const arr = [];\n  while (mask > 0) {\n    arr.push(mask % radix);\n    mask = Math.floor(mask / radix);\n  }\n  return new Array<number>(numElems - arr.length).fill(0).concat(arr.reverse());\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function permutationToLex(permutation: number[]): number {\n  const n = permutation.length;\n  let lexicographicIdx = 0;\n  for (let i = 0; i < n - 1; i++) {\n    lexicographicIdx = lexicographicIdx * (n - i);\n    for (let j = i + 1; j < n; j++) {\n      if (permutation[i] > permutation[j]) {\n        lexicographicIdx += 1;\n      }\n    }\n  }\n  return lexicographicIdx;\n}\n\n// From https://www.jaapsch.net/puzzles/compindx.htm#perm\nexport function lexToPermutation(\n  numPieces: number,\n  lexicographicIdx: number,\n): number[] {\n  const permutation: number[] = new Array(numPieces);\n  permutation[numPieces - 1] = 0;\n  for (let i = numPieces - 2; i >= 0; i--) {\n    permutation[i] = lexicographicIdx % (numPieces - i);\n    lexicographicIdx = Math.floor(lexicographicIdx / (numPieces - i));\n    for (let j = i + 1; j < numPieces; j++) {\n      if (permutation[j] >= permutation[i]) {\n        permutation[j] = permutation[j] + 1;\n      }\n    }\n  }\n  return permutation;\n}\n", "import { KPattern, type KPatternData } from \"../../kpuzzle\";\nimport {\n  experimental3x3x3KPuzzle,\n  experimentalNormalize3x3x3Orientation,\n  experimentalPuzzleOrientation3x3x3Cache,\n  experimentalPuzzleOrientation3x3x3Idx,\n} from \"../../puzzles/cubing-private\";\nimport {\n  identityPermutation,\n  lexToPermutation,\n  maskToOrientations,\n  orientationsToMask,\n  permutationToLex,\n} from \"./orbit-indexing\";\n\n// TODO: combine with `orientPuzzle`?\nexport function reorientPuzzle(\n  pattern: KPattern,\n  idxU: number,\n  idxL: number,\n): KPattern {\n  return pattern.applyTransformation(\n    experimentalPuzzleOrientation3x3x3Cache()[idxU][idxL].invert(),\n  );\n}\n\ntype Binary3x3x3Pattern = Uint8Array;\n\n// Bit lengths of the encoded components, in order.\nconst BIT_LENGTHS = [29, 12, 16, 13, 3, 2, 1, 12];\n\n// These fields are sorted by the order in which they appear in the binary format.\nexport interface Binary3x3x3Components {\n  epLex: number; // 29 bits, edge permutation\n  eoMask: number; // 12 bits, edge orientation\n  cpLex: number; // 16 bits, corner permutation\n  coMask: number; // 13 bits, corner orientation\n  poIdxU: number; // 3 bits, puzzle orientation (U face)\n  poIdxL: number; // 2 bits, puzzle orientation (L face)\n  moSupport: number; // 1 bit, center orientation support\n  moMask: number; // 12 bits, center orientation\n}\n\n// There are various clever ways to do this, but this is simple and efficient.\nfunction arraySum(arr: number[]): number {\n  let total = 0;\n  for (const entry of arr) {\n    total += entry;\n  }\n  return total;\n}\n\n// Due to limitations in JS bit operations, this is unsafe if any of the bit lengths span across the contents of more than 4 bytes.\n// - Safe: [8, 32]\n// - Unsafe: [4, 32, 4]\n// - Unsafe: [40, 4]\nfunction splitBinary(\n  bitLengths: number[],\n  buffy: ArrayBuffer | Uint8Array,\n): number[] {\n  const u8buffy = new Uint8Array(buffy);\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  const values: number[] = [];\n  for (const bitLength of bitLengths) {\n    while (bits < bitLength) {\n      accum = (accum << 8) | u8buffy[at++];\n      bits += 8;\n    }\n    values.push((accum >> (bits - bitLength)) & ((1 << bitLength) - 1));\n    bits -= bitLength;\n  }\n  return values;\n}\n\n// See above for safety notes.\nfunction concatBinary(bitLengths: number[], values: number[]): Uint8Array {\n  const buffy = new Uint8Array(Math.ceil(arraySum(bitLengths) / 8));\n  let at = 0;\n  let bits = 0;\n  let accum = 0;\n  for (let i = 0; i < bitLengths.length; i++) {\n    accum = (accum << bitLengths[i]) | values[i];\n    bits += bitLengths[i];\n    while (bits >= 8) {\n      buffy[at++] = accum >> (bits - 8);\n      bits -= 8;\n    }\n  }\n  if (bits > 0) {\n    buffy[at++] = accum << (8 - bits);\n  }\n  return buffy;\n}\n\n// 0x111 (for idxU) means \"not supported\"\nfunction supportsPuzzleOrientation(components: Binary3x3x3Components): boolean {\n  return components.poIdxU !== 7;\n}\n\nfunction hasFullMOData(centerOrientationModData: number[] | undefined): 0 | 1 {\n  if (!centerOrientationModData) {\n    return 1;\n  }\n  for (let i = 0; i < 6; i++) {\n    if (centerOrientationModData[i] !== 0) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nexport function reid3x3x3ToBinaryComponents(\n  pattern: KPattern,\n): Binary3x3x3Components {\n  const normedPattern = experimentalNormalize3x3x3Orientation(pattern);\n\n  const epLex = permutationToLex(normedPattern.patternData[\"EDGES\"].pieces);\n  const eoMask = orientationsToMask(\n    2,\n    normedPattern.patternData[\"EDGES\"].orientation,\n  );\n  const cpLex = permutationToLex(normedPattern.patternData[\"CORNERS\"].pieces);\n  const coMask = orientationsToMask(\n    3,\n    normedPattern.patternData[\"CORNERS\"].orientation,\n  );\n  const [poIdxU, poIdxL] = experimentalPuzzleOrientation3x3x3Idx(pattern);\n\n  const moSupport = hasFullMOData(\n    pattern.patternData[\"CENTERS\"].orientationMod,\n  ); // Required for now.\n  const moMask = moSupport\n    ? orientationsToMask(4, normedPattern.patternData[\"CENTERS\"].orientation)\n    : 0;\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\nexport function binaryComponentsToTwizzleBinary(\n  components: Binary3x3x3Components,\n): Uint8Array {\n  const { epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask } =\n    components;\n\n  return concatBinary(BIT_LENGTHS, [\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  ]);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function reid3x3x3ToTwizzleBinary(\n  pattern: KPattern,\n): Binary3x3x3Pattern {\n  const components: Binary3x3x3Components =\n    reid3x3x3ToBinaryComponents(pattern);\n  return binaryComponentsToTwizzleBinary(components);\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToBinaryComponents(\n  buffer: ArrayBuffer | Uint8Array,\n): Binary3x3x3Components {\n  const [epLex, eoMask, cpLex, coMask, poIdxU, poIdxL, moSupport, moMask] =\n    splitBinary(BIT_LENGTHS, buffer);\n\n  return {\n    epLex,\n    eoMask,\n    cpLex,\n    coMask,\n    poIdxU,\n    poIdxL,\n    moSupport,\n    moMask,\n  };\n}\n\n/** @category Binary 3x3x3 Format */\nexport function binaryComponentsToReid3x3x3(\n  components: Binary3x3x3Components,\n): KPattern {\n  const patternData: KPatternData = {\n    EDGES: {\n      pieces: lexToPermutation(12, components.epLex),\n      orientation: maskToOrientations(2, 12, components.eoMask),\n    },\n    CORNERS: {\n      pieces: lexToPermutation(8, components.cpLex),\n      orientation: maskToOrientations(3, 8, components.coMask),\n    },\n    CENTERS: {\n      pieces: identityPermutation(6),\n      orientation: maskToOrientations(4, 6, components.moMask),\n    },\n  };\n  if (!components.moSupport) {\n    patternData.CENTERS.orientationMod = new Array(6).fill(1);\n  }\n  const normedPattern = new KPattern(experimental3x3x3KPuzzle, patternData);\n\n  if (!supportsPuzzleOrientation(components)) {\n    return normedPattern;\n  }\n\n  return reorientPuzzle(normedPattern, components.poIdxU, components.poIdxL);\n}\n\n// Returns a list of error string.\n// An empty list means validation success.\nfunction validateComponents(components: Binary3x3x3Components): string[] {\n  const errors = [];\n  if (components.epLex < 0 || components.epLex >= 479001600) {\n    errors.push(`epLex (${components.epLex}) out of range`);\n  }\n  if (components.cpLex < 0 || components.cpLex >= 40320) {\n    errors.push(`cpLex (${components.cpLex}) out of range`);\n  }\n  if (components.coMask < 0 || components.coMask >= 6561) {\n    errors.push(`coMask (${components.coMask}) out of range`);\n  }\n  if (components.poIdxU < 0 || components.poIdxU >= 6) {\n    // 0x111 (for idxU) means \"not supported\"\n    if (supportsPuzzleOrientation(components)) {\n      errors.push(`poIdxU (${components.poIdxU}) out of range`);\n    }\n  }\n  // The following cannot be (f decoded from binary properl) out of rangey.\n  if (components.eoMask < 0 || components.eoMask >= 4096) {\n    errors.push(`eoMask (${components.eoMask}) out of range`);\n  }\n  if (components.moMask < 0 || components.moMask >= 4096) {\n    errors.push(`moMask (${components.moMask}) out of range`);\n  }\n  if (components.poIdxL < 0 || components.poIdxL >= 4) {\n    errors.push(`poIdxL (${components.poIdxL}) out of range`);\n  }\n  if (components.moSupport < 0 || components.moSupport >= 2) {\n    errors.push(`moSupport (${components.moSupport}) out of range`);\n  }\n  return errors;\n}\n\n/** @category Binary 3x3x3 Format */\nexport function twizzleBinaryToReid3x3x3(\n  buffy: ArrayBuffer | Uint8Array,\n): KPattern {\n  const components = twizzleBinaryToBinaryComponents(buffy);\n  const errors = validateComponents(components);\n  if (errors.length !== 0) {\n    throw new Error(`Invalid binary pattern components: ${errors.join(\", \")}`);\n  }\n  return binaryComponentsToReid3x3x3(components);\n}\n", "export function bufferToSpacedHex(buffer: ArrayBuffer | Uint8Array): string {\n  // buffer is an ArrayBuffer\n  return (\n    Array.prototype.map.call(new Uint8Array(buffer), (x: number) =>\n      `00${x.toString(16)}`.slice(-2),\n    ) as string[]\n  ).join(\" \");\n}\n\nexport function spacedHexToBuffer(hex: string): Uint8Array {\n  return new Uint8Array(hex.split(\" \").map((c) => parseInt(c, 16)));\n}\n"],
  "mappings": "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",
  "names": []
}
