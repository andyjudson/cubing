{
  "version": 3,
  "sources": ["../../../../src/cubing/search/inside/solve/puzzles/clock.ts", "../../../../src/cubing/vendor/apache/comlink-everywhere/outside/index.ts", "../../../../src/cubing/search/worker-workarounds/index.ts", "../../../../src/cubing/search/instantiator.ts", "../../../../src/cubing/search/outside.ts"],
  "sourcesContent": ["import { randomUIntBelow } from \"random-uint-below\";\n\nconst backMoves = [\"U\", \"R\", \"D\", \"L\", \"ALL\"];\nconst frontMoves = [\"UR\", \"DR\", \"DL\", \"UL\"].concat(backMoves);\n\nexport function randomClockScrambleString(): string {\n  let filteringMoveCount = 0;\n\n  function randomSuffix() {\n    const amount = randomUIntBelow(12);\n    if (amount !== 0) {\n      filteringMoveCount++;\n    }\n    if (amount <= 6) {\n      return `${amount}+`;\n    } else {\n      return `${12 - amount}-`;\n    }\n  }\n\n  const moves = [];\n  function side(families: string[]): void {\n    for (const family of families) {\n      moves.push(`${family}${randomSuffix()}`);\n    }\n  }\n\n  side(frontMoves);\n  moves.push(\"y2\");\n  side(backMoves);\n\n  // https://www.worldcubeassociation.org/regulations/#4b3\n  if (filteringMoveCount < 2) {\n    return randomClockScrambleString();\n  }\n\n  return moves.join(\" \");\n}\n", "import nodeEndpoint from \"../node-adapter\";\n\nexport { wrap } from \"comlink\";\n// Mangled so that bundlers don't try to inline the source.\n\nconst worker_threads_mangled = \"node:w-orker-_threa-ds\";\nconst worker_threads_unmangled = () => worker_threads_mangled.replace(/-/g, \"\");\n\nconst useNodeWorkarounds =\n  typeof globalThis.Worker === \"undefined\" &&\n  typeof (globalThis as any).WorkerNavigator === \"undefined\";\n\nasync function nodeWorker(\n  source: string | URL,\n  options?: { eval?: boolean },\n): Promise<Worker> {\n  const { Worker: NodeWorker } = await import(\n    /* @vite-ignore */ worker_threads_unmangled()\n  );\n  const worker = new NodeWorker(source, options);\n  worker.unref();\n  return nodeEndpoint(worker);\n}\n\nexport async function constructWorker(\n  source: string | URL,\n  options?: { eval?: boolean; type?: WorkerType },\n): Promise<Worker> {\n  let worker: Worker;\n  if (useNodeWorkarounds) {\n    return nodeWorker(source, { eval: options?.eval });\n  } else {\n    if (options?.eval) {\n      const blob = new Blob([source as string], {\n        type: \"application/javascript\",\n      });\n      source = URL.createObjectURL(blob);\n    }\n    worker = new globalThis.Worker(source, {\n      type: options ? options.type : undefined, // TODO: Is it safe to use `options?.type`?\n    });\n  }\n  return worker;\n}\n", "import { exposeAPI } from \"./worker-guard\";\n\nexport async function searchWorkerURLImportMetaResolve(): Promise<string> {\n  // Note:\n  // - We have to hardcode the expected path of the entry file in the ESM build, due to lack of `esbuild` support: https://github.com/evanw/esbuild/issues/2866\n  //   - This URL is based on the assumption that the code from this file ends up in a shared chunk in the `esm` build. This is not guaranteed by `esbuild`, but it consistently happens for our codebase.\n  // - We inline the value (instead of using a constant), to maximize compatibility for hardcoded syntax detection in bundlers.\n  // - `import.meta.resolve(\u2026)` returns a sync result in every environment except `bun`: https://loadeverything.net/#compatibility-dashboard\n  //   - We assume that it's `async`, just in case.\n  // @ts-ignore\n  return import.meta.resolve(\"./search-worker-entry.js\");\n}\n\nexport function searchWorkerURLNewURLImportMetaURL(): URL {\n  // Note:\n  // - We have to hardcode the expected path of the entry file in the ESM build, due to lack of `esbuild` support: https://github.com/evanw/esbuild/issues/795\n  //   - This URL is based on the assumption that the code from this file ends up in a shared chunk in the `esm` build. This is not guaranteed by `esbuild`, but it consistently happens for our codebase.\n  // - We inline the value (instead of using a constant), to maximize compatibility for hardcoded syntax detection in bundlers.\n  return new URL(\"./search-worker-entry.js\", import.meta.url);\n}\n\n// Workaround for `esbuild`: https://github.com/evanw/esbuild/issues/312#issuecomment-1092195778\nexport async function searchWorkerURLEsbuildWorkaround(): Promise<string> {\n  exposeAPI.expose = false;\n  return (await import(\"./search-worker-entry.js\")).WORKER_ENTRY_FILE_URL;\n}\n\nexport function instantiateSearchWorkerURLNewURLImportMetaURL(): Worker {\n  return new Worker(new URL(\"./search-worker-entry.js\", import.meta.url), {\n    type: \"module\",\n  });\n}\n", "import {\n  constructWorker,\n  wrap,\n} from \"../vendor/apache/comlink-everywhere/outside\";\nimport { type WorkerInsideAPI } from \"./inside/api\";\nimport { searchOutsideDebugGlobals } from \"./outside\";\nimport {\n  instantiateSearchWorkerURLNewURLImportMetaURL,\n  searchWorkerURLEsbuildWorkaround,\n  searchWorkerURLImportMetaResolve,\n  searchWorkerURLNewURLImportMetaURL,\n} from \"./worker-workarounds\";\n\nexport interface WorkerOutsideAPI {\n  terminate: () => void; // `node` can return a `Promise` with an exit code, but we match the web worker API.\n}\nexport interface InsideOutsideAPI {\n  insideAPI: WorkerInsideAPI;\n  outsideAPI: WorkerOutsideAPI;\n}\n\nfunction probablyCrossOrigin(workerEntryFileURL: URL): boolean {\n  try {\n    const scriptOrigin = globalThis.location?.origin;\n    const workerOrigin = workerEntryFileURL.origin;\n    return !!scriptOrigin && !!workerOrigin && scriptOrigin !== workerOrigin;\n  } catch {\n    return false;\n  }\n}\n\nasync function instantiateModuleWorker(\n  workerEntryFileURL: string | URL,\n): Promise<InsideOutsideAPI> {\n  // We need the `import.meta.url` base for `bun`.\n  const url = new URL(workerEntryFileURL, import.meta.url);\n  const tryTrampolineFirst = probablyCrossOrigin(url);\n  try {\n    return instantiateModuleWorkerAttempt(url, tryTrampolineFirst);\n  } catch {\n    return instantiateModuleWorkerAttempt(url, !tryTrampolineFirst);\n  }\n}\n\ninterface BunWorker extends Worker {\n  unref?: () => void;\n}\n\nasync function instantiateModuleWorkerAttempt(\n  workerEntryFileURL: URL,\n  crossOriginTrampoline: boolean,\n): Promise<InsideOutsideAPI> {\n  // biome-ignore lint/suspicious/noAsyncPromiseExecutor: TODO\n  return new Promise<InsideOutsideAPI>(async (resolve, reject) => {\n    try {\n      if (!workerEntryFileURL) {\n        reject(new Error(\"Could not get worker entry file URL.\"));\n      }\n      let url: URL = workerEntryFileURL;\n      if (crossOriginTrampoline) {\n        // Standard browser-like environment.\n        const importSrc = `import ${JSON.stringify(\n          workerEntryFileURL.toString(),\n        )};`;\n        const blob = new Blob([importSrc], {\n          type: \"text/javascript\",\n        });\n        url = new URL(URL.createObjectURL(blob));\n      }\n\n      const worker = (await constructWorker(url, {\n        type: \"module\",\n      })) as Worker & {\n        nodeWorker?: import(\"worker_threads\").Worker;\n      } & BunWorker;\n\n      worker.unref?.(); // Unref in `bun`.\n\n      const onError = (e: ErrorEvent) => {\n        reject(e);\n      };\n\n      // TODO: Remove this once we can remove the workarounds for lack of `import.meta.resolve(\u2026)` support.\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          resolve(wrapWithTerminate(worker));\n        } else {\n          reject(\n            new Error(`wrong module instantiation message ${messageData}`),\n          );\n        }\n      };\n\n      if (worker.nodeWorker) {\n        // We have to use `once` so the `unref()` from `comlink-everywhere` allows the process to quit as expected.\n        worker.nodeWorker.once(\"message\", onFirstMessage);\n      } else {\n        worker.addEventListener(\"error\", onError, {\n          once: true,\n        });\n        worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n          once: true,\n        });\n      }\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\n// Maybe some day if we work really hard, this code path can work:\n// - in `node` (https://github.com/nodejs/node/issues/43583#issuecomment-1540025755)\n// - for CDNs (https://github.com/tc39/proposal-module-expressions or https://github.com/whatwg/html/issues/6911)\nexport async function instantiateModuleWorkerDirectlyForBrowser(): Promise<InsideOutsideAPI> {\n  // biome-ignore lint/suspicious/noAsyncPromiseExecutor: TODO\n  return new Promise<InsideOutsideAPI>(async (resolve, reject) => {\n    try {\n      const worker = instantiateSearchWorkerURLNewURLImportMetaURL();\n\n      const onError = (e: ErrorEvent) => {\n        reject(e);\n      };\n\n      // TODO: Remove this once we can remove the workarounds for lack of `import.meta.resolve(\u2026)` support.\n      const onFirstMessage = (messageData: string) => {\n        if (messageData === \"comlink-exposed\") {\n          // We need to clear the timeout so that we don't prevent `node` from exiting in the meantime.\n          resolve(wrapWithTerminate(worker));\n        } else {\n          reject(\n            new Error(`wrong module instantiation message ${messageData}`),\n          );\n        }\n      };\n\n      worker.addEventListener(\"error\", onError, {\n        once: true,\n      });\n      worker.addEventListener(\"message\", (e) => onFirstMessage(e.data), {\n        once: true,\n      });\n    } catch (e) {\n      reject(e);\n    }\n  });\n}\n\nfunction wrapWithTerminate(worker: Worker): InsideOutsideAPI {\n  const insideAPI = wrap<WorkerInsideAPI>(worker);\n  const terminate = worker.terminate.bind(worker);\n  return { insideAPI, outsideAPI: { terminate } };\n}\n\nexport const allInsideOutsideAPIPromises: Promise<InsideOutsideAPI>[] = [];\n\nexport async function instantiateWorker(): Promise<InsideOutsideAPI> {\n  const insideOutsideAPIPromise = instantiateWorkerImplementation();\n  allInsideOutsideAPIPromises.push(insideOutsideAPIPromise);\n  const { insideAPI } = await insideOutsideAPIPromise;\n  insideAPI.setDebugMeasurePerf(searchOutsideDebugGlobals.logPerf);\n  insideAPI.setScramblePrefetchLevel(\n    searchOutsideDebugGlobals.scramblePrefetchLevel,\n  );\n  return insideOutsideAPIPromise;\n}\n\nexport async function mapToAllWorkers(\n  f: (worker: InsideOutsideAPI) => void,\n): Promise<void> {\n  await Promise.all(\n    allInsideOutsideAPIPromises.map((worker) => worker.then(f)),\n  );\n}\n\nasync function instantiateWorkerImplementation(): Promise<InsideOutsideAPI> {\n  if (globalThis.location?.protocol === \"file:\") {\n    console.warn(\n      \"This current web page is loaded from the local filesystem (a URL that starts with `file://`). In this situation, `cubing.js` may be unable to generate scrambles or perform searches in some browsers. See: https://js.cubing.net/cubing/scramble/#file-server-required\",\n    );\n  }\n\n  function failed(methodDescription?: string) {\n    return `Module worker instantiation${\n      methodDescription ? ` ${methodDescription}` : \"\"\n    } failed`;\n  }\n\n  const fallbackOrder: [\n    fn: () => Promise<InsideOutsideAPI>,\n    description: string,\n    warnOnSuccess: null | string,\n  ][] = [\n    [\n      async () =>\n        instantiateModuleWorker(await searchWorkerURLImportMetaResolve()),\n      \"using `import.meta.resolve(\u2026)\",\n      null,\n    ],\n    // TODO: This fallback should be lower (because it's less portable), but we need to try it earlier to work around https://github.com/parcel-bundler/parcel/issues/9051\n    [\n      instantiateModuleWorkerDirectlyForBrowser,\n      \"using inline `new URL(\u2026, import.meta.url)`\",\n      \"may\",\n    ],\n    [\n      async () => instantiateModuleWorker(searchWorkerURLNewURLImportMetaURL()),\n      \"using `new URL(\u2026, import.meta.url)`\",\n      \"will\",\n    ],\n    [\n      async () =>\n        instantiateModuleWorker(await searchWorkerURLEsbuildWorkaround()),\n      \"using the `esbuild` workaround\",\n      \"will\",\n    ],\n  ];\n\n  for (const [fn, description, warnOnSuccess] of fallbackOrder) {\n    try {\n      const worker = await fn();\n      if (warnOnSuccess) {\n        if (searchOutsideDebugGlobals.showWorkerInstantiationWarnings) {\n          console.warn(\n            `Module worker instantiation required ${description}. \\`cubing.js\\` ${warnOnSuccess} not support this fallback in the future.`,\n          );\n        }\n      }\n      return worker;\n    } catch {\n      if (searchOutsideDebugGlobals.showWorkerInstantiationWarnings) {\n        console.warn(`${failed(description)}, falling back.`);\n      }\n    }\n  }\n\n  throw new Error(\n    `${failed()}. There are no more fallbacks available. If you are using Firefox, please update to version 114 or later.`,\n  );\n}\n", "import { Alg } from \"../alg\";\nimport type { KPuzzle } from \"../kpuzzle\";\n// import { preInitialize222 } from \"../implementations/2x2x2\";\nimport type { KPattern } from \"../kpuzzle/KPattern\";\nimport type { PrefetchLevel } from \"./inside/api\";\nimport { randomClockScrambleString } from \"./inside/solve/puzzles/clock\"; // TODO: don't reach into `inside` code.\nimport type { TwsearchOptions } from \"./inside/solve/twsearch\";\nimport {\n  type InsideOutsideAPI,\n  instantiateWorker,\n  mapToAllWorkers,\n} from \"./instantiator\";\n\nlet cachedWorkerInstance: Promise<InsideOutsideAPI> | undefined;\nfunction getCachedWorkerInstance(): Promise<InsideOutsideAPI> {\n  return (cachedWorkerInstance ??= instantiateWorker());\n}\n\n// Pre-initialize the scrambler for the given event. (Otherwise, an event is\n// initialized the first time you ask for a scramble for that event.)\n//\n// Some typical numbers for a fast computer:\n// - 3x3x3 initialization: 200ms\n// - Each 3x3x3 scramble: 50ms\n// - 4x4x4 initialization: 2500ms\n// - Each 4x4x4 scramble: 300ms to 800ms\n//\n// It is safe to immediately call for a scramble\n// any time after starting pre-initialization, or to call for them without\n// pre-initializing. Pre-initializing essentially gives the scramble worker a\n// head start in case a scramble doesn't get requested immediately.\n//\n// Note that events cannot be pre-initialized in parallel. Attempting to\n// pre-initialize multiple events will initialize them consecutively. Scrambles\n// for a given event cannot be computed while another event is being initialized.\nexport function _preInitializationHintForEvent(\n  eventID: string,\n  // callback?: () => void\n): void {\n  switch (eventID) {\n    case \"333oh\":\n      _preInitializationHintForEvent(\"333\");\n      return;\n  }\n  (async () => {\n    await (await getCachedWorkerInstance()).insideAPI.initialize(eventID);\n  })();\n}\n\nexport async function randomScrambleForEvent(eventID: string): Promise<Alg> {\n  switch (eventID) {\n    case \"clock\":\n      return Alg.fromString(await randomClockScrambleString());\n  }\n  const prom = _randomScrambleStringForEvent(eventID);\n  const wat = await prom;\n  return Alg.fromString(wat);\n}\n\nexport async function _randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  if (searchOutsideDebugGlobals.forceNewWorkerForEveryScramble) {\n  }\n  const worker = searchOutsideDebugGlobals.forceNewWorkerForEveryScramble\n    ? await instantiateWorker()\n    : await getCachedWorkerInstance();\n  return worker.insideAPI.randomScrambleStringForEvent(eventID);\n}\n\nexport async function randomScrambleStringForEvent(\n  eventID: string,\n): Promise<string> {\n  switch (eventID) {\n    case \"clock\":\n      return randomClockScrambleString();\n  }\n  return await _randomScrambleStringForEvent(eventID);\n}\n\nexport async function experimentalSolve3x3x3IgnoringCenters(\n  pattern: KPattern,\n): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(\n    await cwi.insideAPI.solve333ToString(pattern.patternData),\n  );\n}\n\nexport async function experimentalSolve2x2x2(pattern: KPattern): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(\n    await cwi.insideAPI.solve222ToString(pattern.patternData),\n  );\n}\n\nexport async function solveSkewb(pattern: KPattern): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(\n    await cwi.insideAPI.solveSkewbToString(pattern.patternData),\n  );\n}\n\nexport async function solvePyraminx(pattern: KPattern): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(\n    await cwi.insideAPI.solvePyraminxToString(pattern.patternData),\n  );\n}\n\nexport async function solveMegaminx(pattern: KPattern): Promise<Alg> {\n  const cwi = await getCachedWorkerInstance();\n  return Alg.fromString(\n    await cwi.insideAPI.solveMegaminxToString(pattern.patternData),\n  );\n}\n\nexport interface SolveTwsearchOptions {\n  generatorMoves?: string[];\n  startPattern?: KPattern;\n  minDepth?: number;\n}\n\nexport async function solveTwsearch(\n  kpuzzle: KPuzzle,\n  pattern: KPattern,\n  options?: SolveTwsearchOptions,\n): Promise<Alg> {\n  const { startPattern, ...otherOptions } = options ?? {};\n  const apiOptions: TwsearchOptions = otherOptions;\n  if (startPattern) {\n    apiOptions.targetPattern =\n      startPattern.experimentalToTransformation()!.transformationData;\n  }\n  const { ...def } = kpuzzle.definition;\n  delete def.experimentalIsPatternSolved;\n  // delete def.derivedMoves;\n  const dedicatedWorker = await instantiateWorker();\n  try {\n    return Alg.fromString(\n      await dedicatedWorker.insideAPI.solveTwsearchToString(\n        def,\n        pattern.patternData,\n        apiOptions,\n      ),\n    );\n  } finally {\n    console.log(\"Search ended, terminating dedicated `twsearch` worker.\");\n    // TODO: support re-using the same worker for multiple searches..\n    await dedicatedWorker.outsideAPI.terminate();\n  }\n}\n\ninterface SearchOutsideDebugGlobals {\n  logPerf: boolean;\n  scramblePrefetchLevel: `${PrefetchLevel}`;\n  disableStringWorker: boolean;\n  forceNewWorkerForEveryScramble: boolean;\n  showWorkerInstantiationWarnings: boolean;\n}\nexport const searchOutsideDebugGlobals: SearchOutsideDebugGlobals = {\n  logPerf: true,\n  scramblePrefetchLevel: \"auto\",\n  disableStringWorker: false,\n  forceNewWorkerForEveryScramble: false,\n  showWorkerInstantiationWarnings: true,\n};\n\nexport function setSearchDebug(\n  options: Partial<SearchOutsideDebugGlobals>,\n): void {\n  const { logPerf, scramblePrefetchLevel } = options;\n  if (typeof logPerf !== \"undefined\") {\n    searchOutsideDebugGlobals.logPerf = logPerf;\n    mapToAllWorkers((worker) => worker.insideAPI.setDebugMeasurePerf(logPerf));\n  }\n  if (typeof scramblePrefetchLevel !== \"undefined\") {\n    searchOutsideDebugGlobals.scramblePrefetchLevel = scramblePrefetchLevel;\n    mapToAllWorkers((worker) =>\n      worker.insideAPI.setScramblePrefetchLevel(\n        scramblePrefetchLevel as PrefetchLevel,\n      ),\n    );\n  }\n  if (\"disableStringWorker\" in options) {\n    searchOutsideDebugGlobals.disableStringWorker =\n      !!options.disableStringWorker;\n  }\n  if (\"forceNewWorkerForEveryScramble\" in options) {\n    searchOutsideDebugGlobals.forceNewWorkerForEveryScramble =\n      !!options.forceNewWorkerForEveryScramble;\n  }\n  if (\"showWorkerInstantiationWarnings\" in options) {\n    searchOutsideDebugGlobals.showWorkerInstantiationWarnings =\n      !!options.showWorkerInstantiationWarnings;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
