{
  "version": 3,
  "sources": ["../../../../src/cubing/kpuzzle/combine.ts", "../../../../src/cubing/kpuzzle/construct.ts", "../../../../src/cubing/kpuzzle/KPattern.ts", "../../../../src/cubing/kpuzzle/KTransformation.ts", "../../../../src/cubing/kpuzzle/calculate.ts", "../../../../src/cubing/kpuzzle/KPuzzle.ts"],
  "sourcesContent": ["import { isOrbitTransformationDataIdentityUncached } from \"./calculate\";\nimport type {\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\n\nexport function combineTransformationData(\n  definition: KPuzzleDefinition,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): KTransformationData {\n  const newTransformationData = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    const orbit1 = transformationData1[orbitDefinition.orbitName];\n    const orbit2 = transformationData2[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit2,\n      )\n    ) {\n      // common case for big cubes\n      newTransformationData[orbitDefinition.orbitName] = orbit1;\n    } else if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbit1,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] = orbit2;\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: orbit1.orientationDelta,\n        };\n      } else {\n        const newOri = new Array(orbitDefinition.numPieces);\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newOri[idx] =\n            (orbit1.orientationDelta[orbit2.permutation[idx]] +\n              orbit2.orientationDelta[idx]) %\n            orbitDefinition.numOrientations;\n          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];\n        }\n        newTransformationData[orbitDefinition.orbitName] = {\n          permutation: newPerm,\n          orientationDelta: newOri,\n        };\n      }\n    }\n  }\n  return newTransformationData;\n}\n\nexport function applyTransformationDataToKPatternData(\n  definition: KPuzzleDefinition,\n  patternData: KPatternData,\n  transformationData: KTransformationData,\n): KPatternData {\n  const newPatternData = {} as KPatternData;\n  for (const orbitDefinition of definition.orbits) {\n    const patternOrbit = patternData[orbitDefinition.orbitName];\n    const transformationOrbit = transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        transformationOrbit,\n      )\n    ) {\n      // common case for big cubes\n      newPatternData[orbitDefinition.orbitName] = patternOrbit;\n    } else {\n      const newPieces = new Array(orbitDefinition.numPieces);\n      if (orbitDefinition.numOrientations === 1) {\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          newPieces[idx] =\n            patternOrbit.pieces[transformationOrbit.permutation[idx]];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: patternOrbit.orientation, // copy all 0\n        };\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      } else {\n        const newOrientation = new Array(orbitDefinition.numPieces);\n        const newOrientationMod: number[] | undefined =\n          patternOrbit.orientationMod\n            ? new Array(orbitDefinition.numPieces)\n            : undefined;\n        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n          const transformationIdx = transformationOrbit.permutation[idx];\n          let mod = orbitDefinition.numOrientations;\n          if (patternOrbit.orientationMod) {\n            const orientationMod =\n              patternOrbit.orientationMod[transformationIdx];\n            newOrientationMod![idx] = orientationMod;\n            mod = orientationMod || orbitDefinition.numOrientations;\n          }\n          newOrientation[idx] =\n            (patternOrbit.orientation[transformationIdx] +\n              transformationOrbit.orientationDelta[idx]) %\n            mod; // We don't have to use `modIntoRange` (assuming input is well-formed), because we're adding.\n          newPieces[idx] = patternOrbit.pieces[transformationIdx];\n        }\n        const newOrbitData: KPatternOrbitData = {\n          pieces: newPieces,\n          orientation: newOrientation,\n        };\n        if (newOrientationMod) {\n          newOrbitData.orientationMod = newOrientationMod;\n        }\n        newPatternData[orbitDefinition.orbitName] = newOrbitData;\n      }\n    }\n  }\n  return newPatternData;\n}\n", "import type { Move } from \"../alg\";\nimport { repeatTransformationUncached } from \"./calculate\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleDefinition,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\n\nconst FREEZE: boolean = false;\n\nconst identityOrbitCache = new Map<number, KTransformationOrbitData>();\nfunction constructIdentityOrbitTransformation(\n  numPieces: number,\n): KTransformationOrbitData {\n  const cached = identityOrbitCache.get(numPieces);\n  if (cached) {\n    return cached;\n  }\n\n  const newPermutation = new Array(numPieces);\n  const newOrientation = new Array(numPieces);\n  for (let i = 0; i < numPieces; i++) {\n    newPermutation[i] = i;\n    newOrientation[i] = 0;\n  }\n  const orbitTransformation = {\n    permutation: newPermutation,\n    orientationDelta: newOrientation,\n  };\n  if (FREEZE) {\n    Object.freeze(newPermutation); // TODO\n    Object.freeze(newOrientation); // TODO\n    Object.freeze(orbitTransformation); // TODO\n  }\n  identityOrbitCache.set(numPieces, orbitTransformation);\n  return orbitTransformation;\n}\n\nexport function constructIdentityTransformationDataUncached(\n  definition: KPuzzleDefinition,\n): KTransformationData {\n  const transformation = {} as KTransformationData;\n  for (const orbitDefinition of definition.orbits) {\n    transformation[orbitDefinition.orbitName] =\n      constructIdentityOrbitTransformation(orbitDefinition.numPieces);\n  }\n  if (FREEZE) {\n    Object.freeze(transformation); // TODO\n  }\n  return transformation;\n}\n\nexport function moveToTransformationUncached(\n  kpuzzle: KPuzzle,\n  move: Move,\n): KTransformationData {\n  function getTransformationData(\n    key: {\n      toString: () => string;\n    },\n    multiplyAmount: number,\n  ): KTransformationData | undefined {\n    const s = key.toString();\n    const movesDef = kpuzzle.definition.moves[s];\n    if (movesDef) {\n      return repeatTransformationUncached(kpuzzle, movesDef, multiplyAmount);\n    }\n    const derivedDef = kpuzzle.definition.derivedMoves?.[s];\n    if (derivedDef) {\n      return repeatTransformationUncached(\n        kpuzzle,\n        kpuzzle.algToTransformation(derivedDef).transformationData,\n        multiplyAmount,\n      );\n    }\n    return undefined;\n  }\n\n  // TODO: Use Euclid's algorithm to pre-calculate the GCD of moves for each\n  // quantum, along with its transformation. This will make lookup `O(1)` for multiples of e.g. `y2`.\n\n  const data =\n    getTransformationData(move.quantum, move.amount) ??\n    // Handle e.g. `y2` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move, 1) ??\n    // Handle e.g. `y2'` if `y2` is defined.\n    // Note: this doesn't handle multiples.\n    getTransformationData(move.invert, -1);\n\n  if (data) {\n    return data;\n  }\n  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);\n}\n", "import type { KPuzzle } from \"./KPuzzle\";\nimport type { Alg, Move } from \"../alg\";\nimport { applyTransformationDataToKPatternData } from \"./combine\";\nimport type { KTransformationSource } from \"./KPuzzle\";\nimport type {\n  KPatternData,\n  KTransformationData,\n  KTransformationOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\nimport { isPatternDataIdentical } from \"./calculate\";\n\nexport class KPattern {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly patternData: KPatternData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      patternData: this.patternData,\n    };\n  }\n\n  static fromTransformation(transformation: KTransformation): KPattern {\n    const newPatternData = applyTransformationDataToKPatternData(\n      transformation.kpuzzle.definition,\n      transformation.kpuzzle.definition.defaultPattern,\n      transformation.transformationData,\n    );\n    return new KPattern(transformation.kpuzzle, newPatternData);\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KPattern {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(transformation: KTransformation): KPattern {\n    if (transformation.isIdentityTransformation()) {\n      return new KPattern(this.kpuzzle, this.patternData);\n    }\n    const newPatternData = applyTransformationDataToKPatternData(\n      this.kpuzzle.definition,\n      this.patternData,\n      transformation.transformationData,\n    );\n    return new KPattern(this.kpuzzle, newPatternData);\n  }\n\n  applyMove(move: Move | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KPattern {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  isIdentical(other: KPattern): boolean {\n    return isPatternDataIdentical(\n      this.kpuzzle,\n      this.patternData,\n      other.patternData,\n    );\n  }\n\n  /** @deprecated */\n  experimentalToTransformation(): KTransformation | null {\n    if (!this.kpuzzle.canConvertDefaultPatternToUniqueTransformation()) {\n      return null;\n    }\n    const transformationData: KTransformationData = {};\n    for (const [orbitName, patternOrbitData] of Object.entries(\n      this.patternData,\n    )) {\n      const transformationOrbit: KTransformationOrbitData = {\n        permutation: patternOrbitData.pieces,\n        orientationDelta: patternOrbitData.orientation,\n      };\n      transformationData[orbitName] = transformationOrbit;\n    }\n    return new KTransformation(this.kpuzzle, transformationData);\n  }\n\n  experimentalIsSolved(options: {\n    ignorePuzzleOrientation: boolean;\n    ignoreCenterOrientation: boolean;\n  }): boolean {\n    if (!this.kpuzzle.definition.experimentalIsPatternSolved) {\n      throw new Error(\n        \"`KPattern.experimentalIsPatternSolved()` is not supported for this puzzle at the moment.\",\n      );\n    }\n    return this.kpuzzle.definition.experimentalIsPatternSolved(this, options);\n  }\n}\n", "import type { Alg, Move } from \"../alg\";\nimport {\n  invertTransformation,\n  isTransformationDataIdentical,\n  repeatTransformationUncached,\n  transformationRepetitionOrder,\n} from \"./calculate\";\nimport { combineTransformationData } from \"./combine\";\nimport { constructIdentityTransformationDataUncached } from \"./construct\";\nimport type { KPuzzle, KTransformationSource } from \"./KPuzzle\";\nimport type { KTransformationData } from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\n\nexport class KTransformation {\n  constructor(\n    public readonly kpuzzle: KPuzzle,\n    public readonly transformationData: KTransformationData,\n  ) {}\n\n  toJSON(): any {\n    return {\n      experimentalPuzzleName: this.kpuzzle.name(),\n      transformationData: this.transformationData,\n    };\n  }\n\n  invert(): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      invertTransformation(this.kpuzzle, this.transformationData),\n    );\n  }\n\n  // For optimizations, we want to make it cheap to rely on optimizations when a\n  // transformation is an identity. Here, we try to make it cheaper by:\n  // - only calculating when needed, and\n  // - caching the result.\n  #cachedIsIdentity: boolean | undefined; // TODO: is `null` worse here?\n  isIdentityTransformation(): boolean {\n    return (this.#cachedIsIdentity ??= this.isIdentical(\n      this.kpuzzle.identityTransformation(),\n    ));\n  }\n\n  /** @deprecated */\n  static experimentalConstructIdentity(kpuzzle: KPuzzle) {\n    const transformation = new KTransformation(\n      kpuzzle,\n      constructIdentityTransformationDataUncached(kpuzzle.definition),\n    );\n    transformation.#cachedIsIdentity = true;\n    return transformation;\n  }\n\n  isIdentical(t2: KTransformation): boolean {\n    return isTransformationDataIdentical(\n      this.kpuzzle,\n      this.transformationData,\n      t2.transformationData,\n    );\n  }\n\n  // Convenience function\n  /** @deprecated */\n  apply(source: KTransformationSource): KTransformation {\n    return this.applyTransformation(this.kpuzzle.toTransformation(source));\n  }\n\n  applyTransformation(t2: KTransformation): KTransformation {\n    if (this.kpuzzle !== t2.kpuzzle) {\n      throw new Error(\n        `Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`,\n      );\n    }\n\n    if (this.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, t2.transformationData);\n    }\n    if (t2.#cachedIsIdentity) {\n      return new KTransformation(this.kpuzzle, this.transformationData);\n    }\n\n    return new KTransformation(\n      this.kpuzzle,\n      combineTransformationData(\n        this.kpuzzle.definition,\n        this.transformationData,\n        t2.transformationData,\n      ),\n    );\n  }\n\n  applyMove(move: Move | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.moveToTransformation(move));\n  }\n\n  applyAlg(alg: Alg | string): KTransformation {\n    return this.applyTransformation(this.kpuzzle.algToTransformation(alg));\n  }\n\n  // Convenience. Useful for chaining.\n  toKPattern(): KPattern {\n    return KPattern.fromTransformation(this);\n  }\n\n  // TODO: support calculating this for a given start state. (For `R U R' U` on 3x3x3, should this default to 5 or 10?)\n  repetitionOrder(): number {\n    return transformationRepetitionOrder(this.kpuzzle.definition, this);\n  }\n\n  selfMultiply(amount: number): KTransformation {\n    return new KTransformation(\n      this.kpuzzle,\n      repeatTransformationUncached(\n        this.kpuzzle,\n        this.transformationData,\n        amount,\n      ),\n    );\n  }\n}\n", "import {\n  Alg,\n  Commutator,\n  Conjugate,\n  Grouping,\n  LineComment,\n  Move,\n  Newline,\n  Pause,\n  TraversalDownUp,\n} from \"../alg\";\nimport { functionFromTraversal } from \"../alg\";\nimport { combineTransformationData } from \"./combine\";\nimport type { KPuzzle } from \"./KPuzzle\";\nimport type {\n  KPuzzleOrbitDefinition,\n  KTransformationOrbitData,\n  KTransformationData,\n  KPuzzleDefinition,\n  KPatternData,\n  KPatternOrbitData,\n} from \"./KPuzzleDefinition\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport function isOrbitTransformationDataIdentityUncached(\n  numOrientations: number,\n  orbitTransformationData: KTransformationOrbitData,\n): boolean {\n  // TODO\n  // if (o === lasto) {\n  //   return true;\n  // }\n  if (!orbitTransformationData.permutation) {\n    console.log(orbitTransformationData);\n  }\n  const { permutation } = orbitTransformationData;\n  const numPieces = permutation.length;\n  for (let idx = 0; idx < numPieces; idx++) {\n    if (permutation[idx] !== idx) {\n      return false;\n    }\n  }\n  if (numOrientations > 1) {\n    const { orientationDelta: orientation } = orbitTransformationData;\n    for (let idx = 0; idx < numPieces; idx++) {\n      if (orientation[idx] !== 0) {\n        return false;\n      }\n    }\n  }\n  // lasto = o; // TODO\n  return true;\n}\n\nexport function isOrbitTransformationDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitTransformationData1: KTransformationOrbitData,\n  orbitTransformationData2: KTransformationOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePiecePermutation?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      orbitTransformationData1.orientationDelta[idx] !==\n        orbitTransformationData2.orientationDelta[idx]\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePiecePermutation &&\n      orbitTransformationData1.permutation[idx] !==\n        orbitTransformationData2.permutation[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isTransformationDataIdentical(\n  kpuzzle: KPuzzle,\n  transformationData1: KTransformationData,\n  transformationData2: KTransformationData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitTransformationDataIdentical(\n        orbitDefinition,\n        transformationData1[orbitDefinition.orbitName],\n        transformationData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isOrbitPatternDataIdentical(\n  orbitDefinition: KPuzzleOrbitDefinition,\n  orbitPatternData1: KPatternOrbitData,\n  orbitPatternData2: KPatternOrbitData,\n  options: {\n    ignorePieceOrientations?: boolean;\n    ignorePieceIndices?: boolean;\n  } = {},\n): boolean {\n  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n    if (\n      !options?.ignorePieceOrientations &&\n      (orbitPatternData1.orientation[idx] !==\n        orbitPatternData2.orientation[idx] ||\n        (orbitPatternData1.orientationMod?.[idx] ?? 0) !==\n          (orbitPatternData2.orientationMod?.[idx] ?? 0))\n    ) {\n      return false;\n    }\n    if (\n      !options?.ignorePieceIndices &&\n      orbitPatternData1.pieces[idx] !== orbitPatternData2.pieces[idx]\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isPatternDataIdentical(\n  kpuzzle: KPuzzle,\n  patternData1: KPatternData,\n  patternData2: KPatternData,\n): boolean {\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    if (\n      !isOrbitPatternDataIdentical(\n        orbitDefinition,\n        patternData1[orbitDefinition.orbitName],\n        patternData2[orbitDefinition.orbitName],\n      )\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function invertTransformation(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n): KTransformationData {\n  const newTransformationData: KTransformationData = {};\n  for (const orbitDefinition of kpuzzle.definition.orbits) {\n    const orbitTransformationData =\n      transformationData[orbitDefinition.orbitName];\n    if (\n      isOrbitTransformationDataIdentityUncached(\n        orbitDefinition.numOrientations,\n        orbitTransformationData,\n      )\n    ) {\n      newTransformationData[orbitDefinition.orbitName] =\n        orbitTransformationData;\n    } else if (orbitDefinition.numOrientations === 1) {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        newPerm[orbitTransformationData.permutation[idx]] = idx;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: orbitTransformationData.orientationDelta,\n      };\n    } else {\n      const newPerm = new Array(orbitDefinition.numPieces);\n      const newOri = new Array(orbitDefinition.numPieces);\n      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {\n        const fromIdx = orbitTransformationData.permutation[idx];\n        newPerm[fromIdx] = idx;\n        newOri[fromIdx] =\n          (orbitDefinition.numOrientations -\n            orbitTransformationData.orientationDelta[idx] +\n            orbitDefinition.numOrientations) %\n          orbitDefinition.numOrientations;\n      }\n      newTransformationData[orbitDefinition.orbitName] = {\n        permutation: newPerm,\n        orientationDelta: newOri,\n      };\n    }\n  }\n  return newTransformationData;\n}\n\nexport function repeatTransformationUncached(\n  kpuzzle: KPuzzle,\n  transformationData: KTransformationData,\n  amount: number,\n): KTransformationData {\n  // This is used for move construction, so we optimize for the quantum move case.\n  if (amount === 1) {\n    return transformationData;\n  }\n  if (amount < 0) {\n    return repeatTransformationUncached(\n      kpuzzle,\n      invertTransformation(kpuzzle, transformationData),\n      -amount,\n    );\n  }\n  if (amount === 0) {\n    // TODO\n    const { transformationData } = kpuzzle.identityTransformation();\n    return transformationData;\n  }\n  let halfish = transformationData;\n  if (amount !== 2) {\n    halfish = repeatTransformationUncached(\n      kpuzzle,\n      transformationData,\n      Math.floor(amount / 2),\n    );\n  }\n  const twiceHalfish = combineTransformationData(\n    kpuzzle.definition,\n    halfish,\n    halfish,\n  );\n  if (amount % 2 === 0) {\n    return twiceHalfish;\n  } else {\n    return combineTransformationData(\n      kpuzzle.definition,\n      transformationData,\n      twiceHalfish,\n    );\n  }\n}\n\nclass AlgToTransformationTraversal extends TraversalDownUp<\n  KPuzzle,\n  KTransformation\n> {\n  traverseAlg(alg: Alg, kpuzzle: KPuzzle): KTransformation {\n    let transformation: KTransformation | null = null;\n    for (const algNode of alg.childAlgNodes()) {\n      if (transformation) {\n        transformation = transformation.applyTransformation(\n          this.traverseAlgNode(algNode, kpuzzle),\n        );\n      } else {\n        transformation = this.traverseAlgNode(algNode, kpuzzle);\n      }\n    }\n    return transformation ?? kpuzzle.identityTransformation();\n  }\n  traverseGrouping(grouping: Grouping, kpuzzle: KPuzzle): KTransformation {\n    const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);\n    return new KTransformation(\n      kpuzzle,\n      repeatTransformationUncached(\n        kpuzzle,\n        algTransformation.transformationData,\n        grouping.amount,\n      ),\n    );\n  }\n  traverseMove(move: Move, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.moveToTransformation(move);\n  }\n  traverseCommutator(\n    commutator: Commutator,\n    kpuzzle: KPuzzle,\n  ): KTransformation {\n    const aTransformation = this.traverseAlg(commutator.A, kpuzzle);\n    const bTransformation = this.traverseAlg(commutator.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert())\n      .applyTransformation(bTransformation.invert());\n  }\n  traverseConjugate(conjugate: Conjugate, kpuzzle: KPuzzle): KTransformation {\n    const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);\n    const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);\n    return aTransformation\n      .applyTransformation(bTransformation)\n      .applyTransformation(aTransformation.invert());\n  }\n  traversePause(_: Pause, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseNewline(_: Newline, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n  traverseLineComment(_: LineComment, kpuzzle: KPuzzle): KTransformation {\n    return kpuzzle.identityTransformation();\n  }\n}\n\nexport const algToTransformation = functionFromTraversal(\n  AlgToTransformationTraversal,\n);\n\nexport function canConvertDefaultPatternToUniqueTransformationUncached(\n  definition: KPuzzleDefinition,\n): boolean {\n  for (const orbitDefinition of definition.orbits) {\n    const pieces = new Array(orbitDefinition.numPieces).fill(false);\n    for (const piece of this.definition.defaultPattern[\n      orbitDefinition.orbitName\n    ].pieces) {\n      pieces[piece] = true;\n    }\n    for (const piece of pieces) {\n      if (!piece) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction gcd(a: number, b: number): number {\n  if (b) {\n    return gcd(b, a % b);\n  }\n  return a;\n}\n\n/* calculate the order of a particular transformation. */\nexport function transformationRepetitionOrder(\n  definition: KPuzzleDefinition,\n  transformation: KTransformation,\n): number {\n  let order: number = 1;\n  for (const orbitDefinition of definition.orbits) {\n    const transformationOrbit =\n      transformation.transformationData[orbitDefinition.orbitName];\n    const orbitPieces = new Array(orbitDefinition.numPieces);\n    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {\n      if (!orbitPieces[startIdx]) {\n        let currentIdx = startIdx;\n        let orientationSum = 0;\n        let cycleLength = 0;\n        for (;;) {\n          orbitPieces[currentIdx] = true;\n          orientationSum =\n            orientationSum + transformationOrbit.orientationDelta[currentIdx];\n          cycleLength = cycleLength + 1;\n          currentIdx = transformationOrbit.permutation[currentIdx];\n          if (currentIdx === startIdx) {\n            break;\n          }\n        }\n        if (orientationSum !== 0) {\n          cycleLength =\n            (cycleLength * orbitDefinition.numOrientations) /\n            gcd(orbitDefinition.numOrientations, Math.abs(orientationSum));\n        }\n        order = (order * cycleLength) / gcd(order, cycleLength);\n      }\n    }\n  }\n  return order;\n}\n", "import { Alg, Move } from \"../alg\";\nimport type { PGNotation } from \"../puzzle-geometry/PuzzleGeometry\";\nimport { algToTransformation } from \"./calculate\";\nimport { moveToTransformationUncached } from \"./construct\";\nimport type {\n  KPuzzleDefinition,\n  KPuzzleOrbitDefinition,\n  KTransformationData,\n} from \"./KPuzzleDefinition\";\nimport { KPattern } from \"./KPattern\";\nimport { KTransformation } from \"./KTransformation\";\n\nexport type KTransformationSource = Alg | Move | string | KTransformation;\n\nexport class KPuzzle {\n  private experimentalPGNotation: PGNotation | undefined;\n  constructor(\n    public readonly definition: KPuzzleDefinition,\n    options?: {\n      experimentalPGNotation?: PGNotation;\n    },\n  ) {\n    this.experimentalPGNotation = options?.experimentalPGNotation;\n  }\n\n  #indexedOrbits: Record<string, KPuzzleOrbitDefinition> | undefined;\n  // Note: this function is needed much more rarely than you might think. Most\n  // operations related to orbits require iterating through all of them, for\n  // which the following is better:\n  //\n  //    for (const orbitDefinition of kpuzzle.definition.orbits) { // \u2026\n  //    }\n  lookupOrbitDefinition(orbitName: string): KPuzzleOrbitDefinition {\n    this.#indexedOrbits ||= (() => {\n      const indexedOrbits: Record<string, KPuzzleOrbitDefinition> = {};\n      for (const orbitDefinition of this.definition.orbits) {\n        indexedOrbits[orbitDefinition.orbitName] = orbitDefinition;\n      }\n      return indexedOrbits;\n    })();\n    return this.#indexedOrbits[orbitName];\n  }\n\n  name(): string {\n    return this.definition.name; // TODO\n  }\n\n  identityTransformation(): KTransformation {\n    return KTransformation.experimentalConstructIdentity(this);\n  }\n\n  #moveToTransformationDataCache = new Map<string, KTransformationData>();\n  moveToTransformation(move: Move | string): KTransformation {\n    if (typeof move === \"string\") {\n      move = new Move(move);\n    }\n    const cacheKey = move.toString();\n    const cachedTransformationData: KTransformationData | undefined =\n      this.#moveToTransformationDataCache.get(cacheKey);\n    if (cachedTransformationData) {\n      return new KTransformation(this, cachedTransformationData);\n    }\n\n    if (this.experimentalPGNotation) {\n      const transformationData = this.experimentalPGNotation.lookupMove(move);\n      if (!transformationData) {\n        throw new Error(`could not map to internal move: ${move}`);\n      }\n      this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n      return new KTransformation(this, transformationData);\n    }\n\n    const transformationData = moveToTransformationUncached(this, move);\n    this.#moveToTransformationDataCache.set(cacheKey, transformationData);\n    return new KTransformation(this, transformationData);\n  }\n\n  algToTransformation(alg: Alg | string): KTransformation {\n    if (typeof alg === \"string\") {\n      alg = new Alg(alg);\n    }\n    return algToTransformation(alg, this);\n  }\n\n  /** @deprecated */\n  toTransformation(source: KTransformationSource): KTransformation {\n    if (typeof source === \"string\") {\n      return this.algToTransformation(source);\n    } else if ((source as Alg | null)?.is?.(Alg)) {\n      return this.algToTransformation(source as Alg);\n    } else if ((source as Move | null)?.is?.(Move)) {\n      return this.moveToTransformation(source as Move);\n    } else {\n      return source as KTransformation;\n    }\n  }\n\n  defaultPattern(): KPattern {\n    return new KPattern(this, this.definition.defaultPattern);\n  }\n\n  #cachedCanConvertDefaultPatternToUniqueTransformation: boolean | undefined;\n  // TODO: Handle incomplete default pattern data\n  canConvertDefaultPatternToUniqueTransformation(): boolean {\n    return (this.#cachedCanConvertDefaultPatternToUniqueTransformation ??=\n      ((): boolean => {\n        for (const orbitDefinition of this.definition.orbits) {\n          const pieces = new Array(orbitDefinition.numPieces).fill(false);\n          for (const piece of this.definition.defaultPattern[\n            orbitDefinition.orbitName\n          ].pieces) {\n            pieces[piece] = true;\n          }\n          for (const piece of pieces) {\n            if (!piece) {\n              return false;\n            }\n          }\n        }\n        return true;\n      })());\n  }\n}\n"],
  "mappings": "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",
  "names": ["transformationData", "transformationData"]
}
