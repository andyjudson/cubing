import { M as Move, A as Alg } from './Alg.d-Qi_gM3ue.js';

type KPatternData = Record<string, KPatternOrbitData>;
interface KPatternOrbitData {
    pieces: number[];
    orientation: number[];
    /** Each piece may have an "orientation mod" that means "the orientation of
     * this piece is known mod [value]".
     *
     * Suppose `.numOrientations` for this orbit has a value of N. This is
     * considered the default value for the orientation mod of each piece in the
     * orbit.
     *
     * - Each entry must be one of the following:
     *   - A proper divisor of N.
     *     - For example: if N is 12, then one of: 1, 2, 3, 6
     *   - The special value 0, indicating the default value (N).
     *     - This indicates that the orientation of a piece is fully known, i.e.
     *        that its "orientation mod" is the default value (N). However, such a
     *        value is recorded as 0 instead of N, in order to make it simpler to
     *        implement and debug pattern logic involving the default value.
     * - If `.orientationMod[i]` is a proper divisor of N (i.e. not 0), then
     *   `.orientation[i]` must be less than `.orientationMod[i]`. That is, the
     *   orientation values must be individually "normalized" for each piece.
     * - If the `orientationMod` field is not present, then every piece is
     *   considered to have the default value for its "orientation mod".
     *
     * For a "real-world" example of this concept, consider a traditional analog
     * 12-hour clock dial, like one that might hang on the wall in a school room.
     * Although there are 24 hours in a day, A.M. and P.M. times are not
     * distinguishable on such a clock. Since 3:00 (AM) and 15:00 are not
     * distinguishable, we would read either of those times as 3:00 with an
     * implicit "orientation mod" of 12.
     *
     * For most puzzles, however, we care about "visual" indistinguishability
     * rather than "temporal" indistinguishability. To adapt the previous example,
     * imagine a 24-hour clock with 24 hour marks around the dial, but where the
     * hour hand is symmetric and points equally at the current hour as well as
     * its diametic opposite (like a compass needle but painted all in one color).
     * This has the same set of "valid patterns" as a normal 12-hour clock. Such a
     * clock also has an "orientation mod" of 12, but where the multiples of the
     * modulus have been "unfolded" to show their full symmetry instead of being
     * implicit.
     *
     * For a non-trivial puzzle example, consider Eitan's FisherTwist, a shape mod
     * of the 3x3x3 cube:
     * https://www.hknowstore.com/locale/en-US/item.aspx?corpname=nowstore&itemid=97eb4e89-367e-4d02-b7f0-34e5e7f3cd12
     *
     * - The 4 equatorial centers have C₂ symmetry — it is possible to rotate any
     *   of these centers 180° without a visible change to the state. This means
     *   that the possible orientations "loop" after incrementing the orientation
     *   by 2 (two turns clockwise), and therefore the "orientation mod" of a
     *   given piece is only 2.
     *   - If we apply a counter-clockwise rotation to one of these centers, the
     *     transformation applies an orientation of 3. But the net orientation is
     *     recorded as a normalized value of 1 instead, because 3 (mod 2) ≡ 1 (mod
     *     2).
     * - The 2 polar centers (U and D) have no distinguishable rotations. This
     *   means that their orientation is "known mod 1" — any transformation of one
     *   of these centers is indistinguishable from another transformation of the
     *   same center, and all of them are mapped to a value of 0 (the only
     *   possible value that exists mod 1).
     *
     * For 3x3x3:
     *
     * - When solving a normal 3x3x3, center orientations are conventionally
     *   ignored. This is similar to the polar center case for Eitan's
     *   FisherTwist, and the "orientation mod" of each piece is 1. This is also
     *   the core motivating use case.
     * - For a supercube
     *   (https://experiments.cubing.net/cubing.js/twisty/supercube.html) or the
     *   general case of a "picture cube", all four center orientations are
     *   distinguishable for every center. This means all centers have the default
     *   orientation mod of 4. As documented above, this can be recorded with a
     *   `.orientationMod` of `[0, 0, 0, 0, 0, 0]`, or equivalently by omitting
     *   the `.orientationMod` field.
     * - When modeling a real 3x3x3 speedcube, it is common to have a logo on a
     *   single sticker. If you want to model the exact visually distinguishable
     *   states of such a puzzles, it is possible to use an `.orientationMod` such
     *   as `[0, 1, 1, 1, 1, 1]`. For example, this can make it easy to find an
     *   alg for a given case "while keeping the logo the same", without placing
     *   more restrictions on other centers (which could make the search slower or
     *   produce longer solutions).
     *
     * For those with a mathematical background, you may notice a relationship to
     * the concept of a coset (https://en.wikipedia.org/wiki/Coset). For example,
     * consider the group of patterns of a `KPuzzle` (without indistinguishable
     * pieces) generated by a set of transformations. We can assign each set of
     * piece orbits an orientation mod value (which must be identical for all
     * constituent pieces of the same orbit). Each such choice generates a set of
     * valid `KPattern`s that forms a subgroup, and each set of valid `.orientation`
     * values defines one coset of this set. However, note that the set of valid
     * `KPattern`s does *not* form a group when there are any pieces with different
     * `.orientationMod` values that share an orbit.
     *
     * --------
     *
     * Note that the concept of "orientation mod" exclusively applies to `KPattern`,
     * not `KTransformation`. If we tried to apply the orientation mod
     * calculations to the *transformations* of Eitan's FisherTwist, then `SWAP =
     * [U, M' E2 M]` would be indistinguishable from the identity. This would mean
     * that if we calculated `SWAP` and then used this calculation for `S SWAP
     * S'`, then we would conclude that it has no net effect. However, `S SWAP S'`
     * does *not* have the same effect as doing nothing — it visibly rotates the L
     * and R centers! (In mathematical terms: the set of `KTransformation`s would
     * not form a valid set of semigroup actions, due to broken associativity.)
     *
     * Although there are times that we could theoretically save some time/space
     * by ignoring some information when it's not needed for working with certain
     * `KTransformation`s (e.g. ignoring all center orientations for 3x3x3), it is
     * more practical for each `KTransformation` to always track the full range
     * for each piece's `.orientation`. For example:
     *
     * - This is simpler, both conceptually and in code.
     * - This allows changing the set of moves for a puzzle, without recalculating
     *   cached transformations or certain lookup tables (useful for alg
     *   searches).
     * - This allows swapping out a normal 3x3x3 in a `<twisty-player>` for a
     *   picture cube, without re-calculating the center orientations of the
     *   current alg.
     *
     * These use cases may not be strictly "necessary", but the opposite behaviour
     * might be surprising or frustrating if someone does not expect it. So we
     * implement it this way.
     *
     * Informally, the `KTransformation` has the full responsibility for tracking
     * "what really happens" — even if the effect is invisible in some cases,
     * while the `KPattern` tracks both what "is" and what "isn't" known.
     **/
    orientationMod?: number[];
}
type KTransformationData = Record<string, KTransformationOrbitData>;
interface KTransformationOrbitData {
    permutation: number[];
    orientationDelta: number[];
}
interface KPuzzleOrbitDefinition {
    orbitName: string;
    numPieces: number;
    numOrientations: number;
}
interface KPuzzleDefinition {
    name: string;
    orbits: KPuzzleOrbitDefinition[];
    defaultPattern: KPatternData;
    moves: Record<string, KTransformationData>;
    derivedMoves?: Record<string, string>;
    experimentalIsPatternSolved?: (kpattern: KPattern, options: {
        ignorePuzzleOrientation: boolean;
        ignoreCenterOrientation: boolean;
    }) => boolean;
}

declare class KTransformation {
    #private;
    readonly kpuzzle: KPuzzle;
    readonly transformationData: KTransformationData;
    constructor(kpuzzle: KPuzzle, transformationData: KTransformationData);
    toJSON(): any;
    invert(): KTransformation;
    isIdentityTransformation(): boolean;
    /** @deprecated */
    static experimentalConstructIdentity(kpuzzle: KPuzzle): KTransformation;
    isIdentical(t2: KTransformation): boolean;
    /** @deprecated */
    apply(source: KTransformationSource): KTransformation;
    applyTransformation(t2: KTransformation): KTransformation;
    applyMove(move: Move | string): KTransformation;
    applyAlg(alg: Alg | string): KTransformation;
    toKPattern(): KPattern;
    repetitionOrder(): number;
    selfMultiply(amount: number): KTransformation;
}

interface NotationMapper {
    notationToInternal(move: Move): Move | null;
    notationToExternal(move: Move): Move | null;
}

declare function parseOptions(argv: string[]): {
    puzzleDescription: PuzzleDescription | null;
    options: PuzzleGeometryOptions;
};
type FaceName = string;
type OrientationDirection = [number, number, number];
type FaceBasedOrientationDescription = [
    [
        FaceName,
        OrientationDirection
    ],
    [
        FaceName,
        OrientationDirection
    ]
];
type BaseFaceCount = 4 | 6 | 8 | 12 | 20;
type FaceBasedOrientationDescriptionLookup = Record<BaseFaceCount, FaceBasedOrientationDescription>;
declare class PuzzleGeometryFullOptions {
    verbosity: number;
    allMoves: boolean;
    outerBlockMoves: boolean;
    vertexMoves: boolean;
    addRotations: boolean;
    moveList: string[] | null;
    fixedOrientation: boolean;
    fixedPieceType: null | "e" | "v" | "f";
    orientCenters: boolean;
    includeCornerOrbits: boolean;
    includeCenterOrbits: boolean;
    includeEdgeOrbits: boolean;
    excludeOrbits: string[];
    optimizeOrbits: boolean;
    grayCorners: boolean;
    grayCenters: boolean;
    grayEdges: boolean;
    puzzleOrientation: FaceBasedOrientationDescription | null;
    puzzleOrientations: FaceBasedOrientationDescriptionLookup | null;
    scrambleAmount: number;
    constructor(options?: PuzzleGeometryOptions);
}
type PuzzleGeometryOptions = Partial<PuzzleGeometryFullOptions>;

declare class Perm {
    n: number;
    p: number[];
    constructor(a: number[]);
    toString(): string;
    mul(p2: Perm): Perm;
    rmul(p2: Perm): Perm;
    inv(): Perm;
    compareTo(p2: Perm): number;
    toGap(): string;
    toMathematica(): string;
    order(): number;
}

declare class PGOrbitDef {
    size: number;
    mod: number;
    constructor(size: number, mod: number);
    reassemblySize(): bigint;
}
declare class PGOrbitsDef {
    orbitnames: string[];
    private orbitdefs;
    solved: VisibleState;
    movenames: string[];
    moveops: PGTransform[];
    isRotation: boolean[];
    forcenames: boolean[];
    constructor(orbitnames: string[], orbitdefs: PGOrbitDef[], solved: VisibleState, movenames: string[], moveops: PGTransform[], isRotation: boolean[], forcenames: boolean[]);
    toKTransformationData(t: PGTransform): KTransformationData;
    toKPatternData(t: PGTransform): KPatternData;
    static transformToKTransformationData(orbitnames: string[], t: PGTransform): KTransformationData;
    private describeSet;
    toKsolve(name: string, mapper?: NotationMapper): string[];
    toKPuzzleDefinition(includemoves: boolean): KPuzzleDefinition;
    optimize(): PGOrbitsDef;
    scramble(n: number): void;
    getScrambleTransformation(n: number): PGTransform;
    reassemblySize(): bigint;
}
declare class PGOrbit {
    perm: number[];
    ori: number[];
    orimod: number;
    private static ktransformationCache;
    static e(n: number, mod: number): PGOrbit;
    constructor(perm: number[], ori: number[], orimod: number);
    mul(b: PGOrbit): PGOrbit;
    inv(): PGOrbit;
    equal(b: PGOrbit): boolean;
    killOri(): this;
    toPerm(): Perm;
    identicalPieces(): number[][];
    order(): number;
    isIdentity(): boolean;
    private zeroOris;
    remap(no: number[], on: number[], nv: number): PGOrbit;
    remapVS(no: number[], nv: number): PGOrbit;
    appendDefinition(result: string[], name: string, useVS: boolean, concise?: boolean): void;
    toKTransformationOrbitData(): KTransformationOrbitData;
    toKPatternOrbitData(): KPatternOrbitData;
}
declare class PGTransformBase {
    orbits: PGOrbit[];
    constructor(orbits: PGOrbit[]);
    internalMul(b: PGTransformBase): PGOrbit[];
    protected internalInv(): PGOrbit[];
    equal(b: PGTransformBase): boolean;
    protected killOri(): this;
    toPerm(): Perm;
    identicalPieces(): number[][];
    order(): number;
}
declare class PGTransform extends PGTransformBase {
    mul(b: PGTransform): PGTransform;
    mulScalar(n: number): PGTransform;
    inv(): PGTransform;
    e(): PGTransform;
}
declare class VisibleState extends PGTransformBase {
    mul(b: PGTransform): VisibleState;
}

type PuzzleDescriptionString = string;
declare const PGPuzzles: {
    [name: string]: PuzzleDescriptionString;
};
type PuzzleName = keyof typeof PGPuzzles;

declare class Quat {
    a: number;
    b: number;
    c: number;
    d: number;
    constructor(a: number, b: number, c: number, d: number);
    mul(q: Quat): Quat;
    toString(): string;
    dist(q: Quat): number;
    len(): number;
    cross(q: Quat): Quat;
    dot(q: Quat): number;
    normalize(): Quat;
    makenormal(): Quat;
    normalizeplane(): Quat;
    smul(m: number): Quat;
    sum(q: Quat): Quat;
    sub(q: Quat): Quat;
    angle(): number;
    invrot(): Quat;
    det3x3(a00: number, a01: number, a02: number, a10: number, a11: number, a12: number, a20: number, a21: number, a22: number): number;
    rotateplane(q: Quat): Quat;
    orthogonal(): Quat;
    pointrotation(b: Quat): Quat;
    unproject(b: Quat): Quat;
    rotatepoint(q: Quat): Quat;
    rotateface(face: Quat[]): Quat[];
    intersect3(p2: Quat, p3: Quat): Quat | false;
    side(x: number): number;
    /**
     * Cuts a face by this plane, or returns null if there
     * is no intersection.
     * @param face The face to cut.
     */
    cutface(face: Quat[]): Quat[][] | null;
    cutfaces(faces: Quat[][]): Quat[][];
    faceside(face: Quat[]): number;
    sameplane(p: Quat): boolean;
    makecut(r: number): Quat;
}

interface TextureMapper {
    getuv(fn: number, threed: number[]): number[];
}
interface StickerDatSticker {
    coords: number[];
    color: string;
    orbit: string;
    ord: number;
    ori: number;
    face: number;
    isDup?: boolean;
}
interface StickerDatFace {
    coords: number[];
    name: string;
}
type StickerDatAxis = {
    coordinates: number[];
    quantumMove: Move;
    order: number;
};
interface StickerDat {
    stickers: StickerDatSticker[];
    faces: StickerDatFace[];
    axis: StickerDatAxis[];
    unswizzle(mv: Move): Move | null;
    notationMapper: NotationMapper;
    textureMapper: TextureMapper;
}
declare function getPG3DNamedPuzzles(): {
    [s: string]: PuzzleDescriptionString;
};
declare function getPuzzleDescriptionString(puzzleName: PuzzleName): PuzzleDescriptionString;
declare const PUZZLE_BASE_SHAPES: readonly ["c", "t", "o", "d", "i"];
type PuzzleBaseShape = (typeof PUZZLE_BASE_SHAPES)[number];
declare const PUZZLE_CUT_TYPES: readonly ["f", "v", "e"];
type PuzzleCutType = (typeof PUZZLE_CUT_TYPES)[number];
type PuzzleCutDescription = {
    cutType: PuzzleCutType;
    distance: number;
};
type PuzzleDescription = {
    shape: PuzzleBaseShape;
    cuts: PuzzleCutDescription[];
};
declare function parsePuzzleDescription(s: PuzzleDescriptionString): PuzzleDescription | null;
declare function getPuzzleGeometryByDesc(desc: string, options?: PuzzleGeometryOptions): PuzzleGeometry;
declare function getPuzzleGeometryByName(puzzleName: PuzzleName, options?: PuzzleGeometryOptions): PuzzleGeometry;
type MoveSetGeo = [string, string, string, string, number];
/** @category PuzzleGeometry */
declare class PuzzleGeometry {
    puzzleDescription: PuzzleDescription;
    private rotations;
    baseplanerot: Quat[];
    private baseplanes;
    private facenames;
    private faceplanes;
    private edgenames;
    private vertexnames;
    private geonormals;
    private moveplanes;
    private moveplanes2;
    moveplanesets: Quat[][];
    private moveplanenormals;
    movesetorders: number[];
    movesetgeos: MoveSetGeo[];
    private basefaces;
    private faces;
    private facecentermass;
    private baseFaceCount;
    stickersperface: number;
    shortedge: number;
    private markedface;
    cubies: number[][];
    private vertexdistance;
    private edgedistance;
    private facetocubie;
    private facetoord;
    private moverotations;
    private facelisthash;
    private cubiesetnames;
    private cubieords;
    private cubiesetnums;
    private cubieordnums;
    private orbitoris;
    private cubievaluemap;
    private cubiesetcubies;
    cmovesbyslice: number[][][];
    parsedmovelist: [
        string | undefined,
        number,
        number,
        number,
        boolean,
        number
    ][];
    private duplicatedFaces;
    private duplicatedCubies;
    private fixedCubie;
    private net;
    private colors;
    private swizzler;
    notationMapper: NotationMapper;
    private addNotationMapper;
    private setReidOrder;
    private options;
    constructor(puzzleDescription: PuzzleDescription, options: PuzzleGeometryOptions);
    create(puzzleDescription: PuzzleDescription): void;
    private keyface;
    private keyface2;
    private keyface3;
    private findface;
    private project2d;
    allstickers(): void;
    unswizzle(mv: Move): Move | null;
    private stringToBlockMove;
    parseMove(move: Move): [string | undefined, number, number, number, boolean, number];
    private parsemove;
    genperms(): void;
    private getboundarygeometry;
    private getmovesets;
    private graybyori;
    private skipbyori;
    private skipcubie;
    private header;
    writegap(): string;
    writemathematica(): string;
    writeksolve(name?: string): string;
    getKPuzzleDefinition(fortwisty?: boolean, includemoves?: boolean): KPuzzleDefinition;
    getMoveFromBits(moverange: number[], amount: number, inverted: boolean, axiscmoves: number[][], setmoves: number[] | undefined, movesetorder: number): PGTransform;
    private omitSet;
    private diffmvsets;
    getOrbitsDef(fortwisty: boolean, includemoves?: boolean): PGOrbitsDef;
    getScramble(n?: number): KTransformationData;
    getMovesAsPerms(): Perm[];
    showcanon(disp: (s: string) => void): void;
    getsolved(): Perm;
    private getOrientationRotation;
    private getInitial3DRotation;
    private generate2dmapping;
    generatesvg(w?: number, h?: number, trim?: number, threed?: boolean): string;
    get3d(options?: {
        stickerColors?: string[];
        darkIgnoredOrbits?: boolean;
    }): StickerDat;
    getGeoNormal(geoname: string): number[] | undefined;
    private getfaceindex;
    textForTwizzleExplorer(): string;
    writeSchreierSims(tw: (s: string) => void): void;
}
declare class PGNotation {
    private pg;
    private orbitNames;
    constructor(pg: PuzzleGeometry, od: PGOrbitsDef);
    lookupMove(move: Move): KTransformationData | null;
    remapKPuzzleDefinition(kpuzzleDefinition: KPuzzleDefinition): KPuzzleDefinition;
}

type KTransformationSource = Alg | Move | string | KTransformation;
declare class KPuzzle {
    #private;
    readonly definition: KPuzzleDefinition;
    private experimentalPGNotation;
    constructor(definition: KPuzzleDefinition, options?: {
        experimentalPGNotation?: PGNotation;
    });
    lookupOrbitDefinition(orbitName: string): KPuzzleOrbitDefinition;
    name(): string;
    identityTransformation(): KTransformation;
    moveToTransformation(move: Move | string): KTransformation;
    algToTransformation(alg: Alg | string): KTransformation;
    /** @deprecated */
    toTransformation(source: KTransformationSource): KTransformation;
    defaultPattern(): KPattern;
    canConvertDefaultPatternToUniqueTransformation(): boolean;
}

declare class KPattern {
    readonly kpuzzle: KPuzzle;
    readonly patternData: KPatternData;
    constructor(kpuzzle: KPuzzle, patternData: KPatternData);
    toJSON(): any;
    static fromTransformation(transformation: KTransformation): KPattern;
    /** @deprecated */
    apply(source: KTransformationSource): KPattern;
    applyTransformation(transformation: KTransformation): KPattern;
    applyMove(move: Move | string): KPattern;
    applyAlg(alg: Alg | string): KPattern;
    isIdentical(other: KPattern): boolean;
    /** @deprecated */
    experimentalToTransformation(): KTransformation | null;
    experimentalIsSolved(options: {
        ignorePuzzleOrientation: boolean;
        ignoreCenterOrientation: boolean;
    }): boolean;
}

export { KPattern as K, Perm as P, Quat as Q, type StickerDat as S, getPuzzleGeometryByDesc as a, getPuzzleGeometryByName as b, getPG3DNamedPuzzles as c, PuzzleGeometry as d, type StickerDatAxis as e, type StickerDatFace as f, getPuzzleDescriptionString as g, type StickerDatSticker as h, parseOptions as i, type PuzzleGeometryOptions as j, PGNotation as k, type PuzzleCutDescription as l, type PuzzleDescription as m, PUZZLE_CUT_TYPES as n, type PuzzleCutType as o, parsePuzzleDescription as p, PUZZLE_BASE_SHAPES as q, type PuzzleBaseShape as r, KPuzzle as s, KTransformation as t, type PuzzleDescriptionString as u, type KPuzzleDefinition as v, type KPatternData as w, type KPatternOrbitData as x, type KTransformationData as y, type KTransformationOrbitData as z };
